
【匿名性原型】
同一个私钥可以生成多个地址，原则上比特币建议每次交易都使用新地址，这样做到完全的匿名（一个人的所有交易都使用不同的地址，这样完全没法追踪）


【防篡改的原理(不可逆)】
每个节点都保存了一份区块链里所有区块的信息，由于每个区块的header中都包含了上一个区块的hash值（其实不用计算整个区块的hash值，只需要计算父区块header中的hash值就够了，因为父区块header中的Merkle Root值包含了body中所有交易信息的验签），要篡改某块交易信息就得让全网过半节点认可（验证通过）该篡改并且同时修改其所有子节点（最长链原则），由于分布式设计取得全网过半节点对修改的认可几乎是不可能事件。


【账号、地址、私钥】
地址等同于账号，转账操作就是把一个地址的上的未花费（UTXO）转到另一个地址上作为未花费（UTXO）

支付和所有权 实际是同一个问题，如果此比特币只有我可以用来支付，那么说明我拥有所有权

比特币地址和私钥是一个非对称的关系，私钥经过一系列运算（其中有两次Hash）之后，可以得到地址，但是无法从地址反推得到私钥。

地址： 2A39CBa2390FDe
私钥： sdgHsdniNIhdsgaKIhkgnakgaihNKHIskdgal
Hash(Hash(fun(sdgHsdniNIhdsgaKIhkgnakgaihNKHIskdgal)))  -> 2A39CBa2390FDe

实际在签名之前，会先对交易信息进行Hash运算得到摘要信息，然后对摘要信息进行签名。
1、对交易进行hash， 得到一个摘要信息（Hash值）
	hash('    {"付款地址"："2A39CBa2390FDe",
               "收款地址"："AAC9CBa239aFcc",
               "金额"："0.2btc"}
	    ') -> 8aDB23CDEA6
2、用私钥对交易摘要进行签名（付款方在安全的环境下进行，以避免私钥泄密）, 用代码表示大概是这样：
	sign("8aDB23CDEA6", "J78sknJhidhLIqdngalket") -> "3cdferdadgadg"
	
	
在签名运算之后，付款节点就开始在全网进行广播：我支付了0.2btc到AAC9CBa239aFcc,签名信息是3cdferdadgadg，你们来确认一下吧。广播过程实际上是发信息到相连的其它节点，其它节点在验证通过后再转发到与之相连的节点，这样的扩散过程。广播的信息包含了交易原始信息和签名信息。

其它节点在收到广播信息之后，会验证签名信息是不是付款方用私钥对交易原始信息签名产生的，如果验证通过说明确实是付款方本人发出的交易，说明交易有效，才会记录到账本中去（实际还会验证付款账号有没有足够的余额）。
验证过程实际是签名过程的逆运算，用代码表示大概过程是这样的：
	verify("3cdferdadgadg", "2A39CBa2390FDe") -> "8aDB23CDEA6"
	
如果验证输出的信息和原始交易信息的hash一致，则验证通过，记录账本。
大家可以理解为付款地址为公钥，签名过程即为用私钥对交易摘要的加密过程，验证过程为用公钥解密的过程(为方便大家理解，严格来讲是不准确的)。

比特币系统使用了椭圆曲线签名算法，算法的私钥由32个字节随机数组成，通过私钥可以计算出公钥，公钥经过一序列哈希算法和编码算法得到比特币地址，地址也可以理解为公钥的摘要。


【工作量证明Proof of Work(PoW)】共识协议组成一
记账规则：
1、一段时间内（10分钟左右，具体时间会与密码学难题难度相互影响）只有一人可以记账成功；
2、通过解决密码学难题（即工作量证明）竞争获得唯一记账权
3、其他节点复制记账结果


在进行工作量证明之前，记账节点会做进行如下准备工作：
1、收集广播中还没有被记录账本的原始交易信息；
2、检查每个交易信息中付款地址有没有足够的余额；
3、验证交易是否有正确的签名；
4、把验证通过的交易信息进行打包记录；
5、添加一个奖励交易：给自己的地址增加12.5比特币（此处不包括手续费）

Work的具体内容：
比特币的header中有一个nonce随机数，所有矿机去猜一个正确的随机数，使得整个区块的hash值计算出来的前n位为0，率先找到这个随机数的节点获得此次记账的唯一记账权。


在节点成功找到满足的Hash值之后，会马上对全网进行广播打包区块，网络的节点收到广播打包区块，会立刻对其进行验证。

如果验证通过，则表明已经有节点成功解迷，自己就不再竞争当前区块打包，而是选择接受这个区块，记录到自己的账本中，然后进行下一个区块的竞争猜谜。网络中只有最快解谜的区块，才会添加的账本中，其他的节点进行复制，这样就保证了整个账本的唯一性。


【节点发现】
1、节点会记住它最近成功连接的网络节点，当重新启动后它可以迅速与先前的对等节点网络重新建立连接。
2、节点会在失去已有连接时尝试发现新节点。
3、当建立一个或多个连接后，节点将一条包含自身IP地址消息发送给其相邻节点。相邻节点再将此消息依次转发给它们各自的相邻节点，从而保证节点信息被多个节点所接收、保证连接更稳定。
4、新接入的节点可以向它的相邻节点发送获取地址getaddr消息，要求它们返回其已知对等节点的IP地址列表。节点可以找到需连接到的对等节点。
5、在节点启动时，可以给节点指定一个正活跃节点IP, 如果没有，客户端也维持一个列表，列出了那些长期稳定运行的节点。这样的节点也被称为种子节点（其实和BT下载的种子文件道理是一样的），就可以通过种子节点来快速发现网络中的其他节点。


比特币节点通常采用TCP协议、使用8333端口与相邻节点建立连接,建立连接时也会有认证“握手”的通信过程，用来确定协议版本，软件版本，节点IP，区块高度等。


当节点连接到相邻节点后，接着就开始跟相邻节点同步区块链数据（轻量级钱包应用SPV其实不会同步所有区块数据），节点们会交换一个getblocks消息，它包含本地区块链最顶端的哈希值。如果某个节点识别出它接收到的哈希值并不属于顶端区块，而是属于一个非顶端区块的旧区块，就说其自身的本地区块链比其他节点的区块链更长，并告诉其他节点需要补充区块，其他节点发送getdata消息来请求区块，验证后更新到本地区块链中。



【Merkle树】
Merkle树是一种由hash值作为各节点内容的二叉树，比特币block header中包含本区块所有交易作为叶子节点生成的Merkle树的root的hash值，可用于交易有效性（确认属于本区块的交易）的快速验证。
比特币中叶子节点是计算单个交易数据块的hash，其他父节点是计算两个子节点拼接字符串的hash

                   hash12345678(root)
				  /              \
	   	hash1234		            hash5678
		/       \                  /        \
   hash12        hash34       hash56        hash78
   /    \        /    \       /    \        /    \
hash1  hash2  hash3  hash4  hash5  hash6  hash7  hash8	
tran1  tran2  tran3  tran4  tran5  tran6  tran7  tran8	
				 
SPV节点只下载区块头，不下载每个区块中的交易信息（body），这样的区块链大小只有完整区块链的千分之一，SPV通过Merkle树验证交易有效性。

因为Merkle树是二叉树，所以它需要偶数个叶子节点。如果仅有奇数个交易需要归纳，那最后的交易就会被复制一份以构成偶数个叶子节点，这种偶数个叶子节点的树也被称为平衡树。

假如要验证tran6，SPV节点通过Merkleblock消息向相邻拥有完整区块信息的节点(重点！！！)索要验证路径上的所有哈希值，即hash6,hash5,hash56,hash78,hash5678,hash1234,hash12345678这条认证路径上的哈希值，确认交易的存在性和正确性，时间复杂度为log(N)



【未花费交易UTXO】
UTXO（Unspent Transaction Output）比特币的交易都是基于UTXO上的，即交易的输入是之前交易未花费的输出，这笔交易的输出可以被当做下一笔新交易的输入。
挖矿奖励属于一个特殊的交易（称为coinbase交易），可以没有输入。UTXO是交易的基本单元，不能再分割。


【最长链选择】共识协议组成二
分布式节点中，存在两个节点同时计算出结果的情况，此时两个节点同时生成新区块并分发给相邻节点，新区块分别称为A1和B1，网络上其他节点收到A1或者B1后会放弃当前的计算并紧接着A1或者B1计算接下来的A2或者B2区块，放弃原因如下：
1、此时即使计算出有效结果C3，由于A1和B1已经传播过一段时间，C3的传播节奏不可能比A1和B1更快，因此很难获得比A1和B1更多的认可，同时所有认可A1和B1的节点会开始计算A2和B2，这样A链和B链长度超过C链的可能性更大，继续计算在经济上明显不合算了；

只接收到A1或者B1的节点继续计算没啥疑问，对于同时接收到A1和B1的节点，会选择其中有更多“工作量”的一条作为主链，另一条作为备用链保存，此时大概率会有一个节点先算出来A2或者B2，假设B2先计算出来并广播出去，则还在计算A2的节点有两种情况：
1、如果此时已接收过B1，则立刻将B链作为主链继续计算B3，A1被抛弃（废链）；
2、如果此时未接收到B1，则B2被视为孤块保存到孤块池中，一旦接收到B1则取出B2并连接到它的父区块，作为主链；

如果A2和B2依然同时生成，则各节点按前述处理直到An和Bn的计算区分出先后为止，根据概率论两条链上每个对应块都同时产生的概率随着块数增多急速变小；

比特币将区块间隔时间设计为10分钟，就是为了在更快速的交易确认和更低的分叉概率上做妥协。因为更短的区块产生间隔会让交易确认更快完成，但是也会导致更加频繁的区块链分叉（传播时间太短，同时PoW太小导致同样数目的节点要在更短时间内计算出结果，同时算出来的概率更高）


【非对称加密举例（RSA）】
前缀知识：
1）选取两个大质数p，q，计算N = p q 及 φ ( N ) = φ (p) φ (q) = (p-1) * (q-1)
2）互质关系：如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是互质关系（coprime）。
3）叫做欧拉函数，是指任意给定正整数N，在小于等于N的正整数之中，有多少个与N构成互质关系。
4）如果n可以分解成两个互质的整数之积， φ(n) = φ(p1p2) = φ(p1)φ(p2)。即积的欧拉函数等于各个因子的欧拉函数之积。
5）选择一个大于1 小于φ(N)的数e，使得 e 和 φ(N)互质，e其实是1和φ(N)之前的一个质数
6）计算d，使得de=1 mod φ(N) 等价于方程式 ed-1 = k φ(N) 求一组解。
7）d 称为e的模反元素，e 和 φ(N)互质就肯定存在d。模反元素是指如果两个正整数a和n互质，那么一定可以找到整数b，使得ab被n除的余数是1，则b称为a的模反元素。
8）N, e)封装成公钥，(N, d)封装成私钥
9）假设m为明文，加密就是算出密文c: m^e mod N = c (明文m用公钥e加密并和随机数N取余得到密文c)
10）解密则是 c^d mod N = m　(密文c用密钥解密并和随机数N取余得到明文m)



1、Alice 随机取大质数P1=53，P2=59，那N=53*59=3127，φ(N)=(53-1)*(59-1)=3016，φ(N)是欧拉函数
2、取一个e=3，计算出d=2011
3、只将N=3127，e=3 作为公钥传给Bob（公钥公开）
4、Alice使用c^d mod N = 1394^2011 mod 3127，就能得到明文m=89。 （私钥解密过程）