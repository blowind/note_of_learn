
/**********************                 源代码中的基本配置：

《声明Bean的注解》：以下4种声明等效，一般在 编写功能类 的代码上注解用

@Component("beanName")       // 声明基本的bean组件，引号内是配置的组件ID
@Primary                     // 若多个实现了同一接口的Bean注入时无法选择，则声明时标记为Primary的作为唯一选项

@Service					//  在业务逻辑层(service层)使用

@Repository                 //  在数据访问层(Dao层)使用

@Controller                 //  在展现层(MVC->Spring MVC)中使用


《注入Bean的注解》: 以下3种声明等效，一般在 使用功能类 的代码上注解用

//  自动装备，一般用来构造函数和set函数上，自动生成入参与当前对象的匹配关系
//  置为false之后，自动装配失败不抛出异常，bean不进行装配，如果代码中没有进行null检查，则运行时出现空指针异常
@AutoWired(required=false)         

//  同上，不过AutoWired是spring特有注解，Inject更具通用性，来源于JAVA依赖注入规范
@Inject       //  JSR-330提供的注解

@Resource    //  JSR-250提供的注解

     
/**********************                 spring动作配置：

@configuration           //  配置spring，创建配置类

//自动扫描包名下所有@Service, @Component, @Repository, @Controller并注册为类
@componentScan("com.wisely.highlight_spring4.ch1.di")
@componentScan(basePackages={"soundsystem", "vedio"})             // 启用组件扫描，参数是要扫描的基础包，可以配多个
@componentScan(basePackageClasses={CDPlayer.class, DVDPlayer.class})   // 同上，另一种写法



@Import({CDPlayerConfig.class, CDConfig.class})                          // 使用Import注解导入其他的类，用来进行组合
@ImportResource("classpath:cd-config.xml")                               // 引入配置在xml文件里的bean元素


通过配置区分开发环境/生产环境，没有指定profile的bean始终都会创建，不与激活的profile绑定
@Configuration
@Profile("dev")                         // 指定某个bean属于哪个profile，用于在类级别上。表明只有在dev profile激活时才会创建
public class DevelopmentProfileConfig { 
	@bean(destroyMethod="shutdown")
	public DataSource dataSource() {}
}

@Configuration
@Profile("prod")                        //  当生产环境的profile文件激活时，才生成本类里面的bean
public class ProductionProfileConfig {
	@bean
	public DataSource dataSource() {}
}


public class DataSourceConfig {                        // 基于类方法的 @profile 注解
	@bean(destroyMethod="shutdown")
	@Profile("dev")                           //  基于不同的profile文件，这样可以根据对应生效profile文件配置产生对应的bean
	public DataSource embeddedDataSource() {}
	
	@bean
	@Profile("prod")
	public DataSource jndiDataSource() {}
}

/**********************                 测试文件中的配置：

@RunWith(SprintJUnit4ClassRunner.class)          // 表明在测试开始的时候自动创建Spring的应用上下文
//  表示需要在CDPlayerConfig中加载配置，进而通过Component配置引入了bean
@ContextConfiguration(classes=CDPlayerConfig.class)              







/**********************                      创建配置类/Java配置(推荐)                ****************************/
@configuration           //  配置spring，创建配置类，表明当前的类是一个配置类


//  方法返回的对象，注册为Spring应用上下文中的bean
@bean(name="lonelyHeartsClubBand")
public CompactDisc sgtPeppers() { return new SgtPeppers(); }





/**********************                     AOP                ****************************/

@Aspect                       // 声明是一个切面

@After                     //  定义建言

@Before                     //  定义建言

@Around                     //  定义建言



/**********************                      通过xml装配bean                ****************************/

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

	<bean id="compactDisc" class="soundsystem.SgtPeppers" />               //  除非需要按名字引用bean，否则不需要明确命名
	
	<bean id="cdPlayer" class="soundsystem.CDPlayer">
		<constructor-arg ref="compactDisc" />                    // 将一个ID为compactDisc的bean引用传递到CDPlayer构造器中
	</bean>
	
	<bean id="cdPlayer" class="soundsystem.CDPlayer" c:cd-ref="compactDisc" />   // 功能同上，使用c-命名空间声明，其中cd是形参名
	<bean id="cdPlayer" class="soundsystem.CDPlayer" c:_0-ref="compactDisc" />   // 功能同上，使用形参位置代替形参名
	
	<bean id="compactDisc" class="soundsystem.BlankDisc"
		<constructor-arg value="123423432421343214" />                           //  将字面量注入到构造器
		<constructor-arg><null/></constructor-arg>                               // 对于List集合类型的入参，传null
		<constructor-arg>                                                        // 传List集合入参的另一种方式
			<list>
				<value>aaaaaaaaa</value>
				<value>bbbbbbbb</value>
				<value>ccccccccc</value>
			</list>
		</constructor-arg>
		
		<constructor-arg>                                                        // 传Set集合入参的方式
			<set>
				<value>aaaaaaaaa</value>
				<value>bbbbbbbb</value>
				<value>ccccccccc</value>
			</set>
		</constructor-arg>
		
		<constructor-arg>                                                        // 传List集合入参的方式，其中元素是其他bean引用
			<list>
				<ref bean="sgtPeppers" />
				<ref bean="whiteAlbum" />
				<ref bean="revolver" />
			</list>
		</constructor-arg>
	</bean>
	
	<bean id="compactDisc" class="soundsystem.BlankDisc"
		c:_title="adfadfafdasdfsad"   />                                           //  功能同上，使用c-命名空间模式，title是形参
	
	
	<bean id="cdPlayer" class="soundsystem.CDPlayer">
		<property name="compactDisc" ref="compactDisc" />                                        // 属性注入
	</bean>
	
	<bean id="cdPlayer" class="soundsystem.CDPlayer" p:compactDisc-ref="compactDisc">     // 功能同上，使用p-命名空间模式
	
	
	
	<import resource="cd-config.xml"/>                                               //  引入其他xml文件里的bean
	
	<context:component-scan>                                                         //  启用组件扫描
</beans>




默认情况下，Spring中的bean都是单例


@Bean
@Primary                                //  标示首选的Bean，在JavaConfig配置里生成多个同类Bean元素时用来进行区分
public Dessert iceCream() { return new iceCream(); }

@AutoWired
@Qualifier("iceCream")       //  限定自动装配首选Bean，参数是想要用来注入的Bean的ID，默认是生成Bean对象的方法的首字母小写形式
public void setDessert(Dessert dessert) { this.dessert = dessert; } 

结合声明时限定效果更佳，不会因为重构了Bean所在的方法而导致自动装配生效，如下：
@Component
@Qualifier("cold")                           //   在声明Bean的时候就创建自定义的限定符, AutoWired的地方使用同名限定符
public class IceCream implements Dessert { ... }

使用自定义的限定符注解
@Target({ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Cold {}                        //  创建限定符 Cold

@Target({ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Creamy {}                     //  创建限定符 Creamy

@Component
@Cold
@Creamy                                         //  使用自定义的限定符
public class IceCream implements Dessert { ... }       


@Component
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)     // 每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的Bean实例
public class Notepad {... }

@Bean
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)      //  在JavaConfig配置中声明原型范围
public Notepad notepad() { return new Notepad(); }


@Component                                          
@Scope(value=WebApplicationContext.SCOPE_SESSION,    //  声明会话作用域的Bean，为每个会话创建一个Bean实例
       proxyMode=ScopedProxyMode.INTERFACES          //  代理要实现ShoppingCart接口，并将调用委托给具体完成购物车会话的实现Bean
public shoppingCart cart() { ... }

ScopedProxyMode.INTERFACES      //  生成的Bean是一个接口类型定义
ScopedProxyMode.TARGET_CLASS    //  生成的Bean是一个类类型定义


//  注入外部的值(采用配置文件在运行时注入)
@Configuration
@PropertySource("classpath:/com/soundsystem/app.properties")       //  声明属性源，引入类路径一个app.properties文件
public class ExpressiveConfig {
	@Autowired
	Environment env;
	
	@Bean
	public BlankDisc disc() {
		return new BlankDisc(env.getProperty("disc.title"), env.getProperty("disc.artist"));
	}
}
其他重载方法
int connectionCount = env.getProperty("db.connection.count", Integer.class, 30);


//  使用组件扫描和自动装配时注入外部配置文件值的方法
public BlankDisc( @Value("${disc.title}") String title,          //  属性占位符  基本格式 ${...}
				  @Value("${disc.artist}") String artist) {
		this.title = title;
		this.artist = artist;
}
同时必须配置如下方法
@Bean
public static PropertySourcesPlaceholderConfigurer placeholderConfigurer() {
	return new PropertySourcesPlaceholderConfigurer();
}

/**********************                      SpEL/Spring表达式                ****************************/


基本格式：  #{...}

#{3.14}                             //  字面值，就是数字 3.14
#{'Hello'}                          //   同上，字符串
#{T(System).currentTimeMillis()}    //  得到计算表达式那一刻的时间毫秒数，T()表达式将java.lang.System视为Java中对应类型
#{sgtPeppers.artist}                //  引用ID为sgtPeppers的属性artist
#{systemProperties['disc.title']}   //  通过systemProperties对象引用系统属性
#{artistSelector.selectArtist()?.toUpperCase()} // 使用Bean对象的方法，注意此处多的?进行类型安全运算，确定前一个方法结果不为NULL

使用T()运算符可以在表达式内部获得一个Class对象，一般用来访问目标类型的静态方法和常量
T(java.lang.Math).PI             // 访问目标类型的常量
T(java.lang.Math).random()       // 访问目标类型的静态方法


public BlankDisc( @Value("#{systemProperties['disc.title']}") String title,          //  Spring表达式
				  @Value("#{systemProperties['disc.artist']}") String artist) {
		this.title = title;
		this.artist = artist;
}