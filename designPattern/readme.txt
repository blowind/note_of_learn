【状态模式】
背景：
场景可以抽象成状态机，通过动作改变状态。

应用场景：
状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。

描述：
1、用户操作一个状态机，通过对状态机的操作（状态机方法调用），让状态机在各个状态间切换
2、将状态图中的状态全部设计成类，将状态之间的转换关系抽取为类方法，将所有这些类方法抽取出来形成一个接口/抽象类，被所有状态类继承。同时每个状态类中包含一个状态机引用（构造器传入），通过该引用改变状态机的当前状态并执行相关动作，如下：
    （1）改变状态机当前状态（setState）（必选）；
	（2）让状态机执行相关配套动作，这些配套动作由状态机提供，改变状态机具体业务值（可选）；
3、状态机初始化时在本地生成了所有状态对象并且声明一个当前状态的变量（所有状态变量声明为接口类型），主要结构如下：
   （1）必须定义setState方法用于各状态对象改变状态机当前状态，对应2.1；
   （2）根据具体情况定义状态机动作方法，用于状态变化时各状态对象操作状态机执行动作，对应2.2； （3）将所有状态变化间客户参与的操作做成方法提供出来（非客户操作作为状态内部操作，可以不暴露），此处建议状态机内操作方法与接口方法同名，具体实现为直接调用当前状态的该同名方法；
   （4）根据客户需求定义状态机查询方法，用于客户查询本地业务变量；
4、客户调用状态机的操作方法和查询方法进行操作，不直接与状态类打交道，如果不查询状态机的当前状态值，客户甚至不需要知道状态类及其接口，只需要知道状态机类。

关键点：
1、状态机内所有状态的类型都声明为接口类型，方便当前状态变量存储，此处利用了继承/多态特性；
2、将所有客户操作相关方法和状态机内部变化方法都抽取出来做成接口，第一版本即实现完全图形态状态机的所有方法；

优点：
1、完全隔离了状态类，非必要可以对客户（调用代码）完全不可见，客户仅操作状态机及其提供的相关操作方法，达到了最好的封装性；
2、新增已有状态间操作时，所有操作方法均已有默认实现，仅需修改相关类方法实现即可；
3、新增一个状态类时，若该状态类仅有内部变化（不需要客户操作，即仅是状态机自发变化或者客户同类操作已实现），则只涉及状态机和关联状态类修改，无需修改接口定义和客户代码；若新增状态涉及客户新操作，则客户代码、状态机、关联状态类、接口方法都需要修改，使用抽象类替代接口时可以省下不相关状态类新增方法实现。


缺点：
1、每个状态类继承了所有接口方法，但是根据状态关系图我们可以知道，对一个状态来说绝大部分接口方法都是不使用的，为了便于扩展每个状态类包含了所有转换状态的类方法。除非状态图是一个两两相连的完全图，否则总有无用类方法。通过继承抽象类可以减少状态类中无用类方法的实现。



【策略模式】
背景：
某个具体事物，其固有的部分行为/特性具有多样性。

应用场景：
类的行为具有多样性的场景，比如不同的鸟的具有不同的叫声，就可以把叫声这一行为抽取出来作为一个类扩展，把该类组合到原来的鸟类里。

描述：
1、将功能父类中多变的类方法抽取出来做成接口，所有该类方法的具体实现作为接口子类继承该接口；
2、功能父类中以接口类型声明原类方法的行为变量，用统一的方法封装具体接口子类的方法（可选）；
3、在功能子类生成时初始化接口类型变量的具体内容，达到延迟绑定/依使用情况确定的目的。若有必要可以添加改变接口类型变量的方法提供给客户代码按需修改分配的接口子类。

关键点：
1、将具有多样性的方法抽取出来做成接口，具体多样性行为继承该接口，然后组合进原来的类；
2、功能父类实例化时，通过构造器明确接口类型变量的具体实例（入参传入，惯常用法），或者通过一个专门的设置方法指定；理想状态是用户使用时确定，最简单的情况是功能子类构造器编码时确定，哪怕此种情况也达到了封装变化，便于修改的目的（变化封装在接口）


优点：
1、针对接口编程，而不是针对实现编程（原来父类中的具体类方法实现，变成了修改后的接口类型声明的变量），所有的变化封装到了接口子类中，新增功能的最小修改可仅限于添加接口子类和修改客户代码。
2、多用组合，少用继承。（多变的部分都用变量组成功能父类的一部分，而不是作为父类类方法给子类继承）

缺点：
1、若客户代码使用功能父类类型声明变量，则使用了两层多态（父类功能类型子类实例，父类接口类型子类实例），若给客户提供了修改接口变量的方法，复杂代码中使用者很可能根本不清楚当前对象的具体行为到底是什么。建议慎用两层多态，即使用功能子类类型声明变量。


【装饰模式】
背景：
某个具体事物，可以添加大量行为/特性形成新事物，但本质不变。

应用场景：
子类爆炸问题。

描述：
将事物基本本质做成抽象类，所有将基本本质的变种做成抽象类的子类，这部分子类具有变种的本质的实现，叫做基础组件。同时，再定义一个抽象类的公共子类，该子类作为所有的添加行为/特性的公共父类（两层继承），叫做装饰父类，可以是抽象类并将需装饰的方法声明为abstract。每个可以修饰本质的行为/特性封装并继承装饰父类成为装饰子类，装饰子类中必然包含一个以基本本质抽象类声明的变量，用于在类初始化时存储传入的变种子类。客户使用时，所有相关变量声明为本质抽象类类型，变量首次初始化时使用变种子类初始话，后续根据设计将该变量作为装饰子类的入参多次初始化并赋值给客户变量，达到根据客户设计需求多次修饰的目的。

关键点：
1、装饰者和被装饰者必须是一样的类型，也就是有共同的超类。此处利用继承达到“类型匹配”，而不是利用继承获得“行为”；
2、我们将装饰者和组件组合时，就是在添加新的行为。所得的新行为，并不是继承自超类，而是由组合对象得来，即我们每次在客户代码不断组合初始化动作的行为。

优点：
1、类应该对扩展开放，对修改关闭。后序功能扩充主要集中在新增变种子类和装饰子类。
2、由于具体客户需求的装饰拼接行为延迟到客户代码层面执行，提高了拼接灵活性的同时显著减少了类数量，所有最终的复合类型都可以通过客户代码的组合近似得到而不需要定义新类型。

缺点：
1、使用时变量类型必须定义为本质抽象类类型，客户使用的复合类型的具体内容在初始化时确认，需要对使用行为可见，否则复合类型的使用者很可能根本不清楚当前对象的具体行为到底是什么。因为变量声明为本质抽象类类型，通过类型看不出信息。
2、只能有效工作于装饰中的一层（最后一层），见《JAVA编程思想》第415页。


【适配器模式】
背景：
两个不同类的事物，具有类似的行为流程；或者事物的旧实现，需要按照新实现进行封装时（行为流程必然是一样的）

应用场景：
包装旧接口形成新接口供客户调用

描述：
将新类中使用的行为封装抽象成接口，适配器新类实现该接口，并在继承的接口方法中调用旧有接口动作。客户代码中使用接口类型作为变量类型，初始化时将被封装对象（旧对象）作为参数传入。

关键点：
1、本质上等于两个事物见加入一层隔离变化，就是个封装层；
2、注意对象适配器和类适配器的区别，因为JAVA不支持类的多重继承，因此无此模式，但C++有

优点：
1、客户代码和接口绑定，而不是和实现帮顶；
1、使用对象组合，以修改的接口包装被适配者（旧类）；
2、被适配者的任何子类，都可以搭配着适配器使用；


【观察者模式】
背景：
客户场景中直接管控操作的某事物的状态发生变化后，需要通知其他事物做相应反应，而反应对象

应用场景：
状态变化触发式监控（对应的轮询监控是过程式编码方法的代表）

描述：
首先定义一个观察者接口，该接口定义一个更新方法，所有监控状态并实时反应的对象继承该接口，在本地重载的更新方法中获取被观察者对象的信息，根据需要执行相关动作（可选）；
其次定义一个主题接口，该接口实现声明注册观察者、通知观察者、移除观察者三个方法（有观察者类型入参），实际操作主题的对象继承该接口，在本地定义一个观察者接口类型声明的队列，每次生成接口对象时在构造函数中调用注册观察者方法将接口对象添加到队列中，通知观察者方法依次调用每个观察者的更新方法，达到通知观察者的目的；
所有客户代码仅操作主题接口对象，该对象主要存储并管理业务状态，客户除了通过对象方法管理各种状态，还通过主题接口的三个方法达到通知的目的。

关键点：
1、观察者接口对象构造函数的入参必须包含一个主题接口对象，用于在构造函数中调用该对象的注册方法，若有必要可以将该对象存储在本地；
2、主题对象中必须包含一个观察者接口类型的集合（数组、队列或者任意能存储对象的集合），用于存储注册时添加的对象；尽量仅在注册观察者、通知观察者、移除观察者三个方法中使用集合元素，达到封装的效果；观察者对象的更新方法仅在主题类的通知观察者方法中使用；
3、主题对象的主要任务还是管理客户关注的状态，所有与观察者模式无关的类方法都要围绕这个中心服务；客户代码操作仅限于主题对象，除了声明初始化外不应该操作观察者对象。

优点：
1、主题对象管理的所有客户状态变更都通过触发式调用通知各观察者，而不是通过死循环的轮询实现；

扩展：
注意到观察者接口在具体观察者、主题接口中都被使用，某种程度上耦合在了所有继承者/调用者中。观察者模式一般是一对多的情况，实际情况里观察者的类型很可能毫无相同点，仅仅是需要在主题状态变更是被通知，并且这些类大概率已经实现，此时给所有观察者添加观察者接口修改工作量巨大，也不符合扩展而不是修改原则。此处.NET中的委托可以解决这个问题。

委托是一种引用方法的类型。一旦为委托分配了方法，委托将与该方法具有完全相同的行为。委托方法的使用可以像其他任何方法一样，具有参数和返回值。委托可以看作是对函数的抽象，是函数的“类”，委托的实例将代表一个具体的函数。观察者模式中使用委托，具体观察者省去了观察者继承观察者接口的操作，进一步解耦；主题接口不依赖观察者接口，省去了注册和移除观察者的方法，通知方法也变成调用主题接口定义的委托对象，不需要对本地存储的具体观察者挨个遍历并调用观察者接口方法。最重要的，一个委托可以搭载多个方法，所有方法被依次唤醒，并且委托对象搭载的方法并不需要属于同一个类。委托的约束是委托对象所搭载的所有方法必须具有相同的原型和形式，也就是拥有相同的参数列表和返回值类型。


【工厂模式】
背景：
工厂由于掌握商品的生产制造过程，导致商品的生产制造相关的处理全部放在工厂的代码实现中，从而产生耦合，当工厂生产的商品种类繁多时，这种工厂对每种特色的同类商品的操作带来了操作爆炸，所有处理陷入if-else的大量无意义判断中。

描述：
1、先为所有产品准备一个商品抽象类作为所有具体商品的父类，将商品特性按大类做成特性变量，将工厂对于这个商品的制造操作按大类做成该商品抽象类的方法；具体商品作为抽象类的子类，使用自己的特点初始化特性变量，使用自己的具体操作重载继承的制造方法。
2、定义一个所有工厂的抽象类作为所有具体工厂的父类，其中所有商品都用商品抽象类类型声明，该工厂抽象类定义创建商品抽象方法，同时根据需要定义对客户提供的各种操作方法，这些方法调用商品的制造方法组合实现；具体工厂重载工厂的创建商品方法，在该方法中根据客户具体要求初始化对应的具体商品对象并将该对象存储在工厂本地变量中，供后续使用；
3、客户使用的工厂变量都使用工厂抽象类类型声明，使用具体工厂类初始化；使用商品抽象类存储工厂生产的商品，客户不直接操作商品的特性和方法，做到解耦。


关键点：
1、商品抽象类的特性变量和方法必须覆盖所有具体商品的全部内容，即具体商品不存在抽象类定义之外的变量和方法；
2、具体工厂类重载的创建商品方法根据客户提供的需求生产具体商品，所有if-else选择都在此方法中完成，简单来说所有具体商品对象都是在这个函数中new出来并返回给外层用商品抽象类类型定义的变量；

优点：
1、将具体商品的诞生完全封装在工厂的一个方法中，新增同类商品时继续新增具体商品类并修改创建商品方法，其他地方不用修改；

缺点：
1、设计之初需要在商品抽象类中包含归纳所有商品特性的变量、操作的方法，因为工厂抽象类和具体工厂类的所有操作和信息变更都是基于已有的商品抽象类提供的方法；新增一个具体商品类若不得不修改商品抽象类，其涉及面和修改影响不可控；

扩展：
抽象工厂模式，提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。即抽象工厂分别定义了创建产品A和产品B的抽象方法，抽象方法A返回一个产品A的抽象接口类型（产品A可能使用材料甲生产，也可能使用材料乙生成，或者不同工厂生产步骤不一样，whatever），抽象方法B返回一个产品B的抽象接口类型，产品A和B都可以由具体工厂生产，至于具体原料和工艺，由各个工厂自己决定。在客户代码处，只需要初始化抽象工厂变量时指定具体的工厂对象，剩下的所有产品变量都可以使用抽象类型定义，并且自适应保证实际产品都是指定的具体产品。

反射：.Net已有的语言机制，让程序抽取配置信息进而使用正确的具体类类型进行操作，将延时帮顶具体类的操作从一般的客户代码指定、客户输入指定进一步延迟到程序运行时根据客户具体配置确定，极大提高了适配性和扩展性。



【命令模式】
背景：
对于一个开关遥控器，每一排遥控选项上仅有开和关两个按钮，两个按钮具体执行的动作，需要根据插装到遥控器上具体的控制器确定，外部客户只关心根据需要在遥控器每个同规格插槽上插装具体控制器后，操作开/关按钮有正确的动作执行，不关心动作执行的具体细节，也不关心控制器和遥控器的适配问题。

描述：
1、先实现各电器各自的具体功能类，这些类只关心功能的具体实现，作为顶层被继承和调用；
2、定义一个命令接口，该接口仅有一个命名为执行的抽象方法；
3、根据开关遥控器的插槽规格，对每个插槽种类（此处仅有开/关两种）定义各个电器的适配类，例如对开关遥控器就是每个电器类对应有两个适配类，分别是开和关，适配类继承命令接口，在构造器中接收具体电器对象作为参数并存储在本地电器变量，在继承的执行方法中调用电器变量的方法完成具体操作；（注意到此处适配类的实现使用参数和本地变量组合了各电器类，而不是使用继承）
4、定义一个无具体动作的适配类继承命令接口，用做遥控器各个开关插槽的默认值；
5、定义遥控器类，在类内部定义命令接口类型的集合（数组、队列或者任意能存储对象的集合），用于存储每个槽位安装的适配器，对于开关遥控器，要定义两个集合，分别存储开和关的适配器；同时，定义插装（设置）适配器、打开、关闭三个方法供客户使用，使得客户根据具体需求安装使用遥控器；插装方法根据传入的具体槽位号、适配器对象在集合中放入适配器对象，打开/关闭方法根据传入的具体槽位号调用集合中该位置对象的执行方法；
6、客户代码可是使用具体电器类、各个适配类进行各种初始化工作，但是具体开关动作的执行，都通过本地的遥控器对象执行，即客户代码只调用遥控器方法，而不调用电器类、适配类的方法。

关键点：
1、遥控器类中只识别命令接口类型和其中的方法，整个类不与具体电器类关联，彻底解耦；
2、将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象，此处将具体请求封装成各个适配类，由客户代码将适配对象提供给遥控器对象，遥控器本身只能识别命令接口抽象出来的信息，不能识别具体适配类；
3、也可以支持撤销操作，在命令接口中添加撤销方法参考执行方法实现即可；

优点：
1、客户代码的所有动作都与具体电器类和适配类的方法解耦，仅涉及遥控器方法的调用；添加新的电器类时，客户代码里除了新增电器类初始化和设置遥控器代码，不用修改其他代码；

缺点：
1、对遥控器插槽的抽象能力有高要求，如果抽象出来的功能太少，添加新类型插槽


【模板模式】
背景：
事物之间有相似的行动流程，就行动流程抽取出来进行复用，本质其实是特性与动作的解耦分离。

描述：
1、将所有共同行动抽取成类方法放到抽象父类中，如果某个类方法在多个成员中共用，则直接在抽象类中实现，否则等待子类重载；同时抽象类中将行动按照共性的执行顺序封装在一个新的类方法中提供给外部使用，由于该方法调用的都是抽象类内部方法，因此做到统一；
2、子类继承并重载具有自己特色的类方法；
3、客户代码调用抽象类封装的方法，做到与具体子类的方法彻底解耦；

关键点：
1、定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
2、抽取出来的共性步骤形成的抽象父类中，会添加一个额外的类方法按照共性步骤依次调用原有的共性操作方法（这些操作方法也上升到抽象类中）

【代理模式】

使用场景：
1、远程代理，为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。
2、虚拟代理，根据需要创建开销很大的对象，通过它来存放实例化需要很长时间的真实对象。
3、安全代理，用来控制真实对象访问时的权限。
4、智能指引，当调用真实的对象时，代理处理另外一些事。如计算真实对象的引用次数，这样当该对象没有引用时，可以自动释放它；或当第一次引用一个持久对象时，将它装入内存；或在访问一个实际对象前，检查是否已经锁定它，以确保其他对象不能改变它。这些都是通过代理在访问一个对象时附加一些内务处理。

【迭代器模式】
背景：
提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。

描述：
1、先定义集合元素的类，在该类中定义元素的特性操作，该类完全独立，具体实现中不迭代器模式发生交集；
2、新迭代器需要继承Iterator接口并实现next,hasNext,remove三个接口方法，并在本地生成一个元素类类型的数组，该数组在构造器中初始化；即新迭代器要继承Iterator接口并组合元素类；
3、定义一个返回迭代器的约束接口，仅含有创建迭代器方法，返回迭代器类型；
4、定义具体的元素集合操作类，继承约束接口并实现；
5、操作者和客户代码包含集合操作类变量，调用该变量的创建迭代器方法获得迭代器，进行业务相关的遍历操作；

【单件模式】
背景：
线程池、缓存、对话框、处理偏好设置和注册表的对象、日志对象、打印机显卡的驱动对象等，只希望有一个实例的场景。

描述：
将构造函数声明为private，同时定义一个静态类方法，该方法判断若本地变量已存储本对象的实例，则直接结束，否则new一个并赋值给本地变量。

关键点：
1、本地变量为静态变量，能长久存储实例；
2、构造函数为私有，仅能在类内部被调用；
3、提供专有的静态类方法，通过类进行调用，供生成唯一一个实例变量，这个静态类方法就是该单例的全局访问点；
多线程场景处理方法：
1）静态类方法加 synchronized 标签，好处是实现简单，坏处是仅第一次调用有意义，后续调用都是无谓的开销（执行效率可能下降100倍）；
public static synchronized Singleton getInstance() { ... }
2）将类内部变量声明为static并且直接new出来初始化赋值，利用JVM的实现保证多线程安全，好处是实现简单，坏处是第一次使用前占用大量资源；（饿汉式单类）
3）静态类方法实现“双重加锁”，通过额外一次判断确保仅执行一次同步操作，缺点是仅支持1.4以上JAVA版本；（此处还有一个缺点，正常来说单件类不允许被继承，继承后可能会增加实例，需要加上final（JAVA）或sealed（C#））（懒汉式单类）
public static Singleton getInstance() {
	if (uniqueInstance == null)	{
		synchronized (Singleton.class) {
			if (uniqueInstance == null) {
				uniqueInstance = new Singleton();
			} 
		} 
	}
	return uniqueInstance; 
}

【外观模式】
背景：
客户代码中瀑布式执行大量动作，后序又配合有对应的大量善后动作。

描述：
将所有动作涉及的类组合封装在一个类里，瀑布式顺序执行的动作封装成一个类方法供客户代码调用，若涉及到结束时善后，同理将所有善后动作封装成一个类方法。

关键点：
1、提供了统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用；
2、所以行为的执行细节如果对客户不重要，则不暴露给客户，通过添加行为的封装层解耦客户和具体组件；即最少知识原则：只和你的密友交谈；
3、外观模式和适配器模式都可以包装许多类，但外观模式的意图是简化接口，对象层面一般是一对多的关系，适配器模式的意图是将接口转换成不同接口，对象层面是一对一的关系。


【原型模式】
背景：
生成一个新对象，该对象与一个已有对象具有相同的类，仅有微小差异时（即大部分内容都可以共用或者开销大的资源可以共用）


描述：
1.0、在已有对象里定义一个Clone()方法，该方法创建一个新对象，然后将当前对象的非静态字段复制到该新对象。如果字段是值类型的，则对该字段执行逐位复制。如果字段是引用类型，则复制引用但不复制引用的对象；原始对象和副本引用同一个对象，该方法将生成的新对象返回。
1.1、实际实现时，多继承语言的已有克隆接口(ICloneable)，实现该接口定义的方法。注意此处有浅复制和深复制的差别，浅复制被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都指向原来的对象（值复制，引用不复制），深复制把引用兑现的变量指向复制过的新对象，而不是原有的被引用的对象，此处深复制需要在具体类实现及封装（此处可能涉及多层嵌套复制，根据具体情况不同复杂度不同）。

关键点：
1、克隆后返回的对象与原对象完全相同，具体差异通过调用新对象的设置方法进行修改，有客户代码进行。

优点：
1、一般在初始化的信息不发生变化的情况下，克隆是最好的办法。既隐藏了对象创建的细节，有对性能是大大的提高（不用重新初始化对象，而是动态的获取对象运行时的状态）。


【建造者模式/生成器模式】
背景：
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

应用场景：
用于创建一些复杂的对象，这些对象内部构建的建造顺序通常是稳定的，但对象内部的构建通常面临着复杂的变化（new出来的对象并没有达到完全体的状态，需要通过调用自身方法进一步构建完善）。

描述：
1、抽取具体产品类的所有构建方法组成一个抽象建造类或者接口，具体建造子类实现所有接口中的方法，这些方法都是构建完善产品的动作，但是不同的类的同名方法具体实现各不相同；
2、定义一个指挥类，该类声明一个接口类型的本地变量用于存储传入的具体产品类，同时定义一个构建产品的公共方法，依次调用本地变量的各个构建方法执行构建动作；
3、客户代码先初始化具体产品变量，然后将其作为参数传给指挥类，指挥类调用构建方法进一步完善产品；

关键点：
1、与工厂模式的差别：工厂模式是直接告知产品名字给工厂，工厂进行具体的生产工作并输出产品，是“工厂->产品”的两级结构；而建造者模式是客户已经自己拿出了具体产品（new具体产品对象），而建造者进一步完善，是“指挥者->建造者->产品”的三级结构。

优点：
1、使得建造代码与表示代码分离，由于建造者隐藏了该产品是如何组装的，所以若需要改变一个产品的内部表示，只需要再定义一个具体的建造者就可以了；

缺点：
1、具体产品类、指挥类对客户代码都是可见的，封装的仅仅是建造类的进一步完善构建动作。


【备忘录模式】
背景：
在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。

描述：
1、Originator管理人负责创建一个备忘录Memento，用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态。Originator可根据需要决定Memento存储Originator的哪些内部状态；
2、Mememto备忘录负责存储Originator对象的内部状态，并可防止Originator以外的其他对象访问备忘录Mememto。备忘录有两个接口，Caretaker只能看到备忘录的窄接口，它只能将备忘录传递给其他对象。Originator能够看到一个宽接口，允许它访问返回到先前状态所需的所有数据。
3、Caretaker管理者负责保存好备忘录Mememto，不能对备忘录的内容进行操作或检查；
4、客户代码使用Originator生成和恢复备忘录，使用Caretaker管理备忘录，在客户角度不接触备忘录类。

关键点：
1、Originator有创建备忘录和恢复备忘录的方法，创建方法在本地新建备忘录对象并存储当前状态，恢复方法使用入参备忘录对象恢复本地状态变量；
2、Mememto内部定义了同Originator一样的状态变量，用于存储Originator状态，并提供接口返回各状态变量的值；
3、Caretaker本地有Mememto的变量或集合，主要用于放置存储了状态的Mememto对象，其仅提供对Mememto的操作，比如设置或者获取，不操作细节；

缺点：
1、备忘录就是存储管理人状态用的，因此需要存储的状态变量备忘录中都有，强耦合，新增状态两者都要修改（可以将所有状态提取成新类）；


【组合模式】
背景：
将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

应用场景：
需求中是体现部分与整体层次的结构时，或者希望用户可以忽略组合对象与单个对象的不同，统一的使用组合结构中的所有对象时，可以考虑使用组合模式。

描述：
1、定义一个结点抽象类型，具有添加、删除和执行三个抽象方法，通过子类对该抽象类方法的不同实现，形成根、枝干、叶子结点。组成一个N叉树；

关键点：
1、每个非叶结点对象里都有一个抽象类类型的集合，结合添加和删除方法，其实就是实现了N叉树的指针功能，指向各个子结点；
2、每个对象都具有类似的结构，仅仅是所处的层次不一样，下层对象是一个缩小版的上层对象，通过将对象构成树形结构来实现“部分-整体”的效果。

优点：
1、基本对象可以被组合成更复杂的组合对象，而这个组合对象又可以被组合，这样不断地递归下去，客户代码中，任何用到基本对象的地方都可以使用组合对象；
2、让客户可以一致的私用组合结构和单个对象；


【桥接模式】
背景：
将抽象部分与它的实现部分分离，使它们都可以独立地变化；

应用场景：
事物的可以按不同的特征进行多种分类且每种分类都覆盖了事物的全集时，不同分类带来的继承爆炸。
即当事物可以按照不同的特征进行分类时，如果将某个特征作为抽象类提取，依赖继承子类的部分实现来达到区分另一个特征的目的，依靠孙子类的继续继承区分下一个特征，此时不仅代码带来根据分类特征导致的子类爆炸（乘数式保证），并且抽象类的分类由2个变3个这种扩展，则所有的子类和孙子类全部要依次扩展，带来修改的爆炸；此时可以考虑用桥接模式解决。

描述：
1、抽象出一个事物的最关键分类特征（或者至少是某业务场景下的本质特诊）作为主要抽象类，子类继承该特征并按具体情况实现，将其他的分类特征抽象成接口，对应子类实现相关接口特征描述方法，在抽象类中定义所有接口的私有变量；
2、客户代码初始化具体接口类型的子类，并作为抽象类变量设置方法的入参，给抽象类中定义的其他特征变量赋值；

关键点：
1、实现系统可能有多角度分类，
2、与策略模式的区别：策略模式是抽取多变行为抽象成接口进行封装扩展（使用组合），桥接模式是抽取分类特征抽象成接口进行封装扩展（使用聚合），行为是没法确定有多少具体种类的（鸟类的鸣叫），而特征基本大体能明确某场景下具体有多少种类（手机上的软件）。个人感觉这两个模式的类图是一样的，其实本质上没有什么差别，只是看问题的角度不同；


优点：
1、优先使用对象的合成/聚合将有助于保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，不太可能增长为不可控制的庞然大物；即将其他不同分类法的特征都作为主类的本地变量处理，将类层次保证在两层。


【职责链模式】
背景：
使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。

应用场景：
多个同类事物（同抽象类的子类）都可以处理一个请求，只是事物的权限/职责大小不同时，可以依据一条单链表将事物串联起来，让他们依次处理，直到找到最合适的事物来处理。

描述：
1、定义一个抽象类，类中有一个抽象处理方法，一个抽象类的本地变量用于指向下一个处理对象，一个设置方法用于指定下一个处理对象；
2、具体处理类重载处理方法，根据本类的职责实现；若具体请求不在本类职责范围，将接受的入参作为参数，调用存储下家的本地变量的处理方法继续执行下去，指导有合适的处理类处理后返回；
3、客户代码使用抽象类类型的变量存储所有生成的具体处理对象，并调用各自的设置方法指定各对象的职责链下家；客户需要处理请求时，将请求作为入参调用职责链中的第一个对象；

优点：
1、客户提交一个请求时，请求是沿链传递直到有一个具体处理对象。接收者和发送者都没有对象的明确信息，且链中的对象自己并不知道链的结构。职责链简化了对象的相互连接，仅需保持只一个指向后继的引用，而不需保持所有的候选接收者的引用；
2、可以随时地增加或修改处理一个请求的结构，增强了给对象指派职责的灵活性；


【中介者模式】不推荐
背景：
用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，可以独立地改变它们之间的交互。

应用场景：
一般应用于一组对象以定义良好但是复杂的方式进行通信的场合。

描述：
1、定义一个行动抽象类，具体的行动对象继承该类并在本地变量存储中介者对象（构造函数传入），具体行动类中的交互方法调用中介者对象的交互方法，将自己及信息作为入参传入；
2、定义一个中介者接口，其中包含一个交互方法；具体中介者类继承该接口，在具体中介者类中用本地变量存储所有具体行动对象（使用设置方法），在交互方法中处理各个具体行动对象之间的交互，方法的入参指定发送请求的对象和动作指令，交互方法根据业务要求发动对应的具体行动对象执行自己的动作；
3、客户代码先初始化中介者对象，然后作为入参依次初始化各个具体行动对象，然后调用中介者对象的设置方法指定各个具体行动对象，后序程序代码只需要调用每个行动对象的交互方法并传入指令即可完成与期望的具体行动对象的交互。

缺点：
1、所有的具体行动对象都在本地存储中介者对象，中介者对象存储了所有具体行动对象，整个设计仅仅是隔绝了各个行动对象之间的互操作，但是耦合性依然很大，将所有的交互变化都封装在中介者中，增加新的具体行动类都要修改中介者类；


【享元模式】
背景：
运用共享技术有效地支持大量细粒度的对象

应用场景：
如果一个应用程序使用了大量的对象，这些对象造成了很大的存储开销，同时对象的差异可以做成状态提取出来，就可以考虑使用享元模式；

描述：
1、定义一个享元接口，该接口声明操作方法，具体的子类实现该方法，具有相同的信息的事物可以使用一个子类定义，有自己的特征不共享的事物使用对应的子类定义；
2、定义一个享元工厂类，该类中有一个享元接口类型的哈希集合，根据不同的关键字创建具体的共享享元对象（共用相同的信息）放入该哈希集合，该创建过程可以在程序启动时即创建，也可以定义内部方法，在外部获取对象时判断对象是否已经生成，未生成才创建；
3、客户代码初始化享元工厂，根据具体的关键字获取享元对象，对于没有共享信息的对象，在客户代码中自己初始化；

关键点：
1、使用哈希集合排除了重复元素，其实不见得要使用哈希，如果自己实现去重判断代码也可以，本模式的要点是尽量共享共同的内容，少生成类实例，减少资源占用；

优点：
1、避免大量非常相似类的开销。在程序设计中，有时需要生成大量细粒度的类实例来表示数据。如果能发现这些实例除了几个参数歪基本都是相同的，有时就能够大幅度的减少需要实例化的类的数量。如果能把这些参数移到类实例的外面，在方法调用时将它们作为参数传递进来，就可以通过共享大幅度地减少单个实例的数目。


【解释器模式】
背景：
1、给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示解释语言中的句子；

描述：
1、正则表达式解释器；

优点：
1、很容易改变和扩展文法，因为该模式使用类来表示文法规则，可使用继承来改变或扩展该文法。比较容易实现文法，因为定义抽象语法树中各个节点的类的实现大体类似，这些类都易于直接编写；

缺点：
1、解释器模式为文法中的每一条规则至少定义了一个类，因此包含许多规则的文法可能难以管理和维护。建议当文法非常复杂时，使用其他的技术如语法分析程序或编译器生成器来处理。

【访问者模式】不常用
背景：
表示一个作用于某对象结构中的各元素的操作。把处理从数据结构分离出来，使得增加新的操作很容易，因为增加新的操作就意味着增加一个新的访问者。

应用场景：
系统有比较稳定的数据结构，又有易于变化的算法，使用访问者模式比较合适，因为访问者模式使得算法操作的增加变得容易。

描述：
1、将系统中具有稳定数据结构的特征抽象成接口，将具体的稳定结构做成他的子类，接口中的共性方法中，调用入参根据本特征实现的抽象方法，并将本对象（this）作为入参传入。例如男人和女人作为抽象类人的稳定分类结构，抽象出接受方法放到人这个抽象类里，男人子类实现接受方法，在其中调用入参“访问者”的“获得男人结论方法”并传入自身this作为参数；同理，女人子类的接受方法里，调用入参“访问者”的“获得女人结论方法”并传入自身this；
2、将多变的状态抽象出固定特征方法做成状态接口供子类具体实现，如状态接口中定义“获得男人结论方法”和“获得女人结论方法”，入参类型为具体的男人/女人子类类型，状态子类实现时根据本子类特征和传入的稳定特征子类确定具体的执行动作；状态接口的子类可以有很多，比如成功、失败、恋爱、结婚等，每个状态里都实现了接口中根据稳定特征定义的各个方法；
3、定义一个执行用的封装类，包含添加、删除、运行三个方法，用于执行稳定特征的操作，添加/删除入参都是稳定特征的子类，执行方法接收状态子类作为参数，循环遍历所有稳定特征对象，调用其接受方法并将状态对象作为参数传入；
4、客户代码因此初始化稳定特征子类，放入封装类，其后根据场景需求初始化某个状态子类，作为封装类运行方法的入参调用执行。感觉封装类和所有的具体类客户代码都要识别，对客户隐藏的仅仅是他们的相互组合关系；

关键点：
1、稳定特征一定是不更改的，比如男人/女人的分类不变多出第三种，因为状态的接口方法会确定男人相关的方法和女人相关的方法（入参类型也是男人/女人的类型），更改会带来整个状态结构从上到下的修改；
2、稳定特征接口中仅包含状态接口类型，状态接口中不仅包含稳定特征的所有子类（用做方法入参），并且方法个数也由稳定特征类别数决定；因此状态接口的耦合性更高，这也是稳定特征稳定性要求的由来；



[创建型模式]
抽象工厂模式、工厂模式、建造者模式、原型模式、单例模式

[结构型模式]
适配器模式、桥接模式、组合模式、装饰模式、外观模式、享元模式、代理模式

[行为型模式]
观察者模式、模板模式、命令模式、状态模式、职责链模式、解释器模式、中介者模式、访问者模式、策略模式、备忘录模式、迭代器模式



基本类见关系：
类继承（空心三角形+实线）：子类继承父类，拥有父类的变量和方法，JAVA里面是一对一；
接口继承（空心三角形+虚线）：子类继承接口，拥有接口定义的方法，JAVA里面是一对多；
组合（菱形+实线+箭头）：一个类中定义了另一个类类型的私有变量，该变量在构造器中初始化；表示一个类拥有另一个类，比如鸟拥有翅膀；如果组合是动态发生的，那么它通常被称为聚合；
关联（箭头+实线）：一个类中定义了另一个类类型的私有变量；表示这个类知道另一个类，比如企鹅类里面放一个气候变量，企鹅知道当前气候；
聚合（空心菱形+实线）：一个类中定义了另一个类类型的集合，集合元素未定（表示一种弱的拥有关系，显示的是A对象包含B对象，B对象不一定是A对象的一部分）；
依赖（箭头+虚线）：一个类的某个非构造函数将另一个类作为入参；比如动物依赖氧气和水；




单一职责原则（SRP）：就一个类而言，应该仅有一个引起它变化的原因。（参见策略模式）
开放-封闭原则：软件实体（类、模块、函数等等）应该可以扩展，但是不可修改。（参见装饰模式）
里氏替换原则（LSP）：子类型必须能够替换掉它们的父类型。即只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。
依赖倒转原则：A.高层模块不依赖底层模块，两个都应该依赖抽象，即高层模块使用关联/组合“接口”或者“抽象类”；B.抽象不应该依赖细节，细节应该依赖抽象，即底层模块继承“接口”或者“抽象类”。
迪米特法则（LoD）：也叫最少知识原则，如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。
合成/聚合复用原则：尽量使用合成/聚合，尽量不要使用类继承。



设计模式的本质：
使用面向对象语言的特性，抽取封装变化，达到高内聚低耦合，使用语言特点进行共性的提升（大量使用接口）
