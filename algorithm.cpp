///  最大子序列和问题:  即给定 (-2, 11, -4, 13, -5, -2)   知道其最大子序列和是11到13之间的20//  方法1：  分治法。分治的思想，整个序列从中间分一般，最大子序列和要么在左边，要么在右边，要么跨越两边//  前两种情况继续递归求解，第三种情况求中点为界的两边的最大值，和起来就是整个最大值//  比较这三个值，从中就可以得到子序列的最大和long result = max_sum(num_array, num_array.begin(), --num_array.end());    // 调用部分，注意所有迭代器都要实指long max_sum(const vector<long> &a, vector<long>::iterator left, vector<long>::iterator right) {  // 实现部分	if(left == right) {		return *left;            //    负数的时候返回负数而不是0	}else{		vector<long>::iterator middle = left + (right - left)/2;    // 此处不能直接相加求和，会超出迭代器范围		long MaxLeftSum = max_sum(a, left, middle);		long MaxRightSum = max_sum(a, middle+1, right);		long leftSum = *middle;      //  防止出现全负数的情况时，强制和为0		long leftTmp = 0;		while(middle >= left) {			leftTmp += *middle;			if(leftTmp > leftSum) {				leftSum = leftTmp;			}			if(middle == a.begin()) {      //  防止迭代器指向第一个元素前面，否则会报运行时错				break;			}else {				middle--;			}		}		middle = left + (right - left)/2 + 1;		long rightSum = *middle;		long rightTmp = 0;		while(middle <= right) {			rightTmp += *middle;			if(rightTmp > rightSum) {				rightSum = rightTmp;			}			middle++;		}		long totalSum = leftSum + rightSum;         //   求三个数中的最大值，可以写个inline函数运行		totalSum = totalSum>=MaxLeftSum?totalSum:MaxLeftSum;		totalSum = totalSum>=MaxRightSum?totalSum:MaxLeftSum;		return totalSum;	}}//  方法2：利用最大子序列和的特性：  最大子序列的第一个元素不可能是负数//     （更确切的说如果序列长度超过1，第一个数不可能是让整个序列的和变小，当序列所有元素为负时，最大子序列仅一个数）//       我们可以把一段序列的和看做一个数，此时，如果他属于最大子序列，则他不可能是负数//   从而最大子序列的特点是：从起始点往后开始求和，整个和永远不可能为负，为负则最大子序列已经求得或者要重新求//   此方法本质上是动态规划的思想：   记 b[j] 为从数组头某个位置开始加到j的最大值//     当b[j-1]>0时，b[j]=b[j-1]+a[j]；  当b[j-1]<=0时，b[j]=a[j];//   得到  b[j] = max{ b[j-1]+a[j], a[j]};int max_sum(int *a, int length) {           //   可解全为负数情况	if(length < 1) return INT_MAX;	if(length < 2) return a[0];	int tmpsum = a[0];	int maxsum = a[0];	for(int i=1; i<length; i++) {		tmpsum += a[i];		if(tmpsum <= a[i]) {			tmpsum = a[i];		}		if(tmpsum > maxsum) {			maxsum = tmpsum;		}	}	return maxsum;}//    此处为该算法使用STL的写法long result = max_sum(num_array, left, right);     // 调用部分，通过2,3号参数返回起始和结束位置cout << result << " " << left-num_array.begin()+1 << " " << right-num_array.begin()+1 << endl;  //  显示结果部分long max_sum(vector<long> &a, vector<long>::iterator &left, vector<long>::iterator &right) {  //  此方法可解负数情况	long MaxSum = *(a.begin());	long TmpSum = 0;	vector<long>::iterator it = a.begin();	left = it;	right = it;	vector<long>::iterator tmpleft = it;;	while(it != a.end()) {		TmpSum += *it;		if(TmpSum > MaxSum) {          // 存储新的最大和			MaxSum = TmpSum;			left = tmpleft;			right = it;		}		if(TmpSum < *it) {        //  当且仅当it之前的部分为负的时候成立，此时需要如果有新的子序列，要重新开始			TmpSum = *it;			tmpleft = it;		}		if(TmpSum > MaxSum) {       //   每次TmpSum变动都要进行更新，防止 -3 -1 -2这种情况			MaxSum = TmpSum;			left = tmpleft;			right = it;		}		it++;	}	return MaxSum;}///  求直方图最大面积问题：对于长度都为1，高度都为正数的连续直方图，求解里面包含的最大矩形的面积//   方法1：分别指向其实位置和结束位置的两个指针，通过两层循环来求取所有面积来得到最大面积//  剪枝的O(n2)算法：每次确定一个右边界，然后在所有的左边界里面找寻最大的面积，//  找右边界的剪枝法：对于相邻的高度递增的直方图i,i+1，如果到i截止能得到最大面积，则到i+1必然能得到更大面积//  所以升序不可能成为右边界，只检查降序情况int max_rectangle_area(int *array, int length) {     // 本来右边界和左边界是要分别考虑的，但对直方图来说，右边界和左边界数组完全相同，可共用	int max_area = 0;	for(int i=0; i<length; i++) {               //  i是右边界数组的下标		for(int j=i+1; j<length; j++) {      //  寻找下降序列的过程			if(array[j] < array[j-1]) {				i = j-1;         //  找到一个下降情况				break;			}else{				i = j;     //   需要每次改变i的值，此处即剪枝的地方，每次i在j内部就跳过升序情况			}		}		int lowest_height = array[i];      //  记录从i往前遍历过程中的最小高度		for(int k=i; k>=0; k--) {          //  k是左边界数组的下标，利用两个边界数组的全等性来直接赋值			if(array[k] < lowest_height) {				lowest_height = array[k];			}			int tmp_area = (i-k+1)*lowest_height;    // 由于共用同一个数组，有一个基本宽度1			if(tmp_area > max_area) {				max_area = tmp_area;			}		}	}	return max_area;}//  方法2：：最大面积的左边界肯定比其左边大，右边界肯定比其右边大，则想办法缓存每个元素的最左边界，//           每次找到最右边界时就计算以此元素为高的最大面积//  O(n)算法的基本思路：用一个栈存储一个递增的高度下标，栈底元素必是已遍历过的元素中高度最小的一//  对每一个当前判断的元素，如果比栈顶元素大，继续入栈(符合栈元素递增特性)//  如果小，求出所有以这个元素高度为下界的栈内元素的面积//  栈中每个元素的前一个元素是其左边界，每次出栈的元素都是已经找到右边界的元素int max_rectangle(int *array, int length) {	stack<int> mystack;	int max_area = 0;	mystack.push(0);        //  第一个元素是当前已知最小，入栈	for(int i=1; i<length; i++) {		// 对于栈内所有比当前元素高度大的元素来说，此时已找到他们的右边界，则计算对应的最大面积		while(!mystack.empty() && array[mystack.top()]>array[i]) {   			int pre = mystack.top();      // 得到当前高度的下标，求出以这个元素为高的最大面积			mystack.pop();     // 弹栈之后，栈顶元素为当前高度的左边界			if(!mystack.empty()) {				// 到i之前的高度都是递增的，所以右界肯定是i-1，对于				max_area = max(max_area, (i-1-mystack.top())*array[pre]); 			}else{				// 如果栈底元素用来作为高度，则长度横贯已知长度，同时也表明i元素为已知所有元素中高度最小的				max_area = max(max_area, (i-0)*array[pre]);  			}		}		// 经过上面while循环的处理，栈内相邻两个元素之间的所有元素的高度必然都是比这两个元素高的		mystack.push(i);  // 最重要的压栈步骤，保证了栈内必有元素和栈元素的递增性	}	//  栈内有元素时，表明最后一个元素的高度大于等于最小元素的高度，这是必然成立的，所以必然有未处理的递增序列	while(!mystack.empty()) {		int pre = mystack.top();		mystack.pop();		if(!mystack.empty()) {			max_area = max(max_area, (length-1-mystack.top())*array[pre]);		}else{			max_area = max(max_area, (length-0)*array[pre]);		}	}	return max_area;}///   整数划分问题，求正整数n的不同划分的个数，从最大加数的角度来解，这是个可以递归划分的部分//    在正整数n的所有划分中，将最大加数n1不大于m的划分个数记作  q(n, m)，整个公式分解如下：             1             n=1, m=1  // 终止条件，1的最大加数为1的只有一种情况             q(n, n)       n<m       //  最大加数不可能大于原来的数q(n, m) =    1 + q(n, n-1) n=m       // 最大加数为n本身的情况只有一种，再加上最大加数小于n的情况             q(n, m-1) + q(n-m, m)  n>m>1    //  此时分为两种情况分别讨论			 //  第一种情况：最大加数不是m，则直接递归求取 q(n, m-1)			 //  第二种情况：最大加数是m，则把m减掉，把剩下的数按最大加数为m进行划分的情况求出 q(n-m, m)int q(int n, int m) {	if(n<1 || m<1) return 0;      //  去掉已不可解的情况	if(n==1 || m==1) return 1;    //  在保证可解的情况下，这种时候只有一个解	if(n<m) return q(n,n);          //  三种情况的具体分析	if(n==m) return 1+q(n,m-1);	return q(n, m-1)+q(n-m, m);}插入排序主要分为：直接插入排序和shell排序///        插入排序: 将数组分为无序区和有序区两个部分，然后不断将无序区的第一个元素按大小插入有序区中，最终达到有序//         要点：设置哨兵，作为临时存储和判断数组边界之用void insert_sort(int *a, int length) {  //  此处length所指向的位置必须有元素，调用的时候需注意	int i,j;      //  i指向有序区的最后一个元素，j指向无序区的第一个元素	for(i=1; i<length; i++) {  		j = i+1;     //   j最终会指向length所在区域		if(a[j]<a[i]) { //   利用前面区域的有序特性判断是否需要插入			a[0] = a[j];               //   a[0]作为哨兵，显著减小了代码量			while(a[0]<a[i]) {            //  查找插入位置并移动元素				a[i+1] = a[i];				i--;			}			a[i+1] = a[0];         //   元素插入		}		i = j-1;    //  还原i为有序区的最后一个元素的指针(此时还不是，得++)	}}///       shell排序：分段的插入排序，先将序列按增量分为元素个数相同的若干组，以每组同标号的元素作为排序组进行插入排序//        要点：增量的合理选择及尾部处理，最终以1为增量进行选择排序主要分为：  直接选择排序  和  堆排序///       直接选择排序: 将序列分为有序区和无序区，每次寻找无序区的最小值与“无序区”的首元素交换，最终完成排序//        要点：从头开始的遍历保证了有序区的“最小”性质，即第一次遍历必然找的是所有元素中最小的，第二次必然是第二小的//           如果是突然给个已经有有序区和无序区的数组，在无序区找的最小元素不见得比有序区的所有元素都大，从而排序错误void select_sort(int *a, int length) {	int i,j,k;     //  i为无序区的起点，j为遍历起点，k为最小元素指示符	for(i=0; i<length-1; i++) {      //   注意到因为j=i+1减少一次无意义比较的优化，所以为防越界i的上限必须为length-1		k=i;               //   默认猜测无序区第一个元素最小		for(j=i+1; j<length; j++) {			if(a[j] < a[k]) {				k = j;             //   指示已知最小元素			}		}		if(k != i) {              //  最小元素与默认不符时，进行交换			a[k] ^= a[i];			a[i] ^= a[k];			a[k] ^= a[i];		}	}}///      堆排序： 先对整个序列建堆，然后每次取堆顶元素放入有序区域，再调整堆的不合法部分直到合法，重复上述过程直到有序//    直接选择排序中，为了从R[1..n]中选出关键字最小的记录，必须进行n-1次比较//    然后在R[2..n]中选出关键字最小的记录，又需要做n-2次比较。//    事实上，后面的n-2次比较中，有许多比较可能在前面的n-1次比较中已经做过，//    但由于前一趟排序时未保留这些比较结果，所以后一趟排序时又重复执行了这些比较操作。//    堆排序可通过树形结构保存部分比较结果，可减少比较次数。//    在任何时刻，堆排序中无序区总是在有序区之前，且有序区是在原向量的尾部由后往前逐步扩大至整个向量为止void heapify(int *a, int parent, int length) {	int child;	int tmp;	for(tmp = a[parent]; 2*parent+1<length; parent = child) {      //  保证大顶，		child = 2*parent + 1;		if(child < length-1 && a[child + 1] > a[child])   //  如果有右孩子，则选取其中较大的一个			child++;		if(a[child] > tmp) {     //  较大的孩子比父节点大，则进行替换			a[parent] = a[child];			a[child] = tmp;  		}else{                 //  否则此链路上堆结构已合法，结束			break;		}			}}void heap_sort(int *a, int length) {  //  length表示数组总长度，不需要0位置作为哨兵	for(int i=length/2-1; i>=0; i--) {      //  建堆操作，i遍历所有非叶节点		heapify(a, i, length);	}	for(int i=length-1; i>0; i--) {         //  每次将大顶堆堆顶元素放入有序区域最开头		a[0] ^= a[i];		a[i] ^= a[0];		a[0] ^= a[i];		heapify(a, 0, i);        //  调整堆，主要是堆顶链路，其他子链路都已合法	}}分配排序主要分为：  箱排序 和  基数排序///      箱排序：建立对应n个不同待排序元素的邻接表，将每个元素插入对应key的链表，然后按key的顺序拼接所有链表元素//       若R[0..n-1]中关键字的取值范围是0到m-1的整数，则必须设置m个箱子。//       因此箱排序要求关键字的类型是有限类型，否则可能要无限个箱子。//       一般情况下每个箱子中存放多少个关键字相同的记录是无法预料的，故箱子的类型应设计成链表为宜。//       基本上排序前得知道元素的上下界，不然无法评估箱子的大小//       箱排序只适用于关键字取值范围较小的情况，否则所需箱子的数目m太多导致浪费存储空间和计算时间。struct element {            //      定义链表结构体，C++中其实是类	int a;	element *next;};void bucket_sort(int *a, int lower, int length) {	element *q = new element[length];	for(int i=0; i<length; i++) {             //   初始化邻接表的数组头部分		q[i].a = INT_MAX;                    //   可以用作哨兵，但是此处没用，无意义		q[i].next = NULL;	}	for(int i=0; i<length; i++) {		element *thisone = new element();		thisone->a = a[i];		element *p = &q[a[i]-lower];		while(true) {			if(p->next == NULL) {          //   找到尾部了，发现自己是链表里最大的元素，插入尾部				thisone->next = p->next;				p->next = thisone;				break;			}			if(thisone->a >= p->next->a) {   //  按从小到大的顺序，等于号保证了算法的稳定性				p = p->next;			}else{				thisone->next = p->next;        //    找到合适的位置，插入				p->next = thisone;				break;			}		}	}	int index = 0;             //        索引原来数组的每个位置	for(int i=0; i<length; i++) {		element *p = q[i].next;		while(p) {			a[index++] = p->a;			p = p->next;		}	}}   ///        合并排序问题：分治法的思想，将待排序序列分为左右两部分，然后各自再调用合并排序，再将两个已排序的部分合并void MergeStandard(int nData[], int nP, int nM, int nR){    int n1 = nM - nP;        //第一个合并数据的长度    int n2 = nR - nM;        //第二个合并数据的长度    int *pnD1 = new int[n1 + 1];        //申请一个保存第一个数据的空间    int *pnD2 = new int[n2 + 1];        //申请二个保存第一个数据的空间    for (int i = 0; i < n1; ++i)        //复制第一个数据到临时空间里面    {        pnD1[i] = nData[nP + i];    }    pnD1[n1] = INT_MAX;                    //将最后一个数据设置为最大值(哨兵)    for (int i = 0; i < n2; ++i)        //复制第二个数据到临时空间里面    {        pnD2[i] = nData[nM + i];    }    pnD2[n2] = INT_MAX;                    //将最后一个数据设置为最大值(哨兵)    n1 =  n2 = 0;	//   通过哨兵的设置，减小了合并时比较的代码开销，不然要通过比较各个位置迭代器的大小来判断运行进度	//   哨兵的思想额外增加了两个空间开销，但减少了大量比较判断代码    while(nP < nR)              {        nData[nP++] = pnD1[n1] <  pnD2[n2] ? pnD1[n1++] : pnD2[n2++];        //取出当前最小值到指定位置    }    delete [] pnD1;        //  防止内存泄露    delete [] pnD2;}void MergeRecursion(int nData[], int nBegin, int nEnd){    if (nBegin == nEnd)        //已经到最小颗粒了,直接返回    {        return;    }    int nMid = (nBegin + nEnd) / 2;            //计算出他们的中间位置，便于分治    MergeRecursion(nData, nBegin, nMid);    //递归调用，合并排序好左边一半    MergeRecursion(nData, nMid+1, nEnd);        //递归调用，合并排序好右边一半    MergeStandard(nData, nBegin, nMid, nEnd);//(用更接近标准的方法合并)}bool MergeSort(int nData[], int nNum){	if(NULL == nData || 0 == nNum)		return;    return MergeRecursion(nData, 0, nNum-1);        //调用递归，完成合并排序}交换排序主要分为：  冒泡排序 和 快速排序///    冒泡排序：  将序列分为无序和有序区，不断对比相邻元素并进行有条件交换直到有序//     要点： 设计交换判断条件，提前结束排序好的序列void bubble_sort(int *a , int length) {           //  length等于整个数组的长度	int i,j;          //   i指向有序区的最后一个元素，j指向无序区的第一个元素	bool flag = false;	for(i=0; i<length-1; i++) {		if(flag)             //   提前排好序的跳出判断			break;		flag = true;		for(j=i+1; j<length; j++) {			if(a[j] < a[j-1]) {				a[j] ^= a[j-1];				a[j-1] ^= a[j];				a[j] ^= a[j-1];				flag = false;			}		}	}}///    快速排序问题：  还是分治法的思想，不过是先分半之后保证两边的特性，再分部进行处理int _partition(int *array, int s, int e) {         //  此处必须保证s一定小于e	int left = s;	int right = e+1;	int anchor = array[s];	while(true) {		while(array[++left]<anchor && left<right);   // 向右找找到左边第一个比anchor大的数，此处的小于保证下面的循环最多让left == right		while(array[--right]>anchor);       //  向左找找到右边第一个比anchor小的数，此处的顺序保证了此处终止时right一定指向比anchor小的数		if(left>=right)   //  要立马判断上一个循环的终止条件，否则right再走一下大循环会继续向前推进一个			break;		array[left] ^= array[right];      //   快速无溢出的交换方法		array[right] ^= array[left];		array[left] ^= array[right];	}	array[s] = array[right];              //  前面的right的保证性使得此处交换一定合理	array[right] = anchor;                //  此处必须用right，因为right循环在后，保证right指向的元素小于anchor	return right;}void _quick_sort(int *array, int s, int e) {           	if(s<e) {                                     //  通过此处的判断，使子函数的调用一定成立		int q = _partition(array, s, e);		_quick_sort(array, s, q-1);		_quick_sort(array, q+1, e);	}}void quick_sort(int *array, int length) {	if(NULL == array || 0 == length) {		return;	}	_quick_sort(array, 0, length-1);}///   寻找第k小的数的问题//    方法一：利用快速排序中使用的分治思想，寻找一个中间比较点，然后根据返回的比较点的位置看k落在哪部分，再递归寻找int random_partition(int *array, int s, int e) {      //  此处必须保证s一定小于e	int left = s;                          //    随机部分实现：范围随便找一个元素与第一个元素替换即可，不细述	int right = e+1;                       //  此方法在 s=0, e=1时依然成立，在 s=e的时候不成立(数组越界)	int anchor = array[s];	while(true) {		while(array[++left]<anchor && left<right);		while(array[--right]>anchor);		if(left>=right)			break;		array[left] ^= array[right];		array[right] ^= array[left];		array[left] ^= array[right];	}	array[s] = array[right];	array[right] = anchor;	return right;}int _random_select_k(int *array, int s, int e, int k) {	if(s == e) {                                       //   能找到此处说明只剩这一个数		return array[s];	}else if(s < e) {		int i = random_partition(array, s, e);		if(k == i) {			return array[k];		}else if(k < i) {			return _random_select_k(array, s, i-1, k);		}else{			return _random_select_k(array, i+1, e, k);		}	}}///   动态规划算法：基本思想也是将待求解问题分解成子问题，然后求解子问题，再从子问题得到原问题的解//    与分治法不同的是，其分解得到的子问题往往不是相互独立的。此时用分治法来解，由于分解得到的子问题太多，耗费指数时间//    用分治法求解时，有些子问题被重复计算多次，动态规划算法用一个表记录所有已解决的子问题，从而避免大量重复计算//    动态规划算法适用于解  “最优化问题”，基本设计步骤如下：//    (1) 找出最优解的性质，刻画其结构特征 (问题的最优子结构性质是该问题可以使用动态规划算法的显著特征)//    (2) 递归的定义最优值//    (3) 以自底向上的方式计算出最优值//    (4) 根据计算最优值时得到的信息，构造最优解 //    动态规划算法有赖于问题本身具有的两个重要性质：(1)最优子结构性质  (2)子问题重叠性质///   矩阵连乘问题：通过合理的组合使得所用乘法计算次数最少//    从上往下，当找到整个序列最后一次相乘点(分割点)时，根据公式：min(all) = min(left) + min(right) + left*mid*right//    由于left,right定死，所以等价于找整个序列的最小mid，同时由于min(all)的最小性，min(left)和min(right)必然也应该最小//    从而得到最优子结构，同时左右两边同样可以递归求解，得到子问题重叠性质//    计算时从底向上，通过连接特性每次找片区里面的最小值//  p数组存储矩阵的行列值，由于可乘特性，p里面含有n+1个元素；n表示元素个数//  m[i][j]存储对应i到j的连乘矩阵的最好划分，s[i][j]对应i到j的连乘矩阵的划分位置k，其中k指向的元素划入前半部分void matrix_chain(int *p, int n ,int m[][7], int s[][7]) {	for(int i=1; i<=n; i++) {         //  对m内容初始化，只有自己一个矩阵时需要使用乘法0次		m[i][i] = 0;	}	for(int r=2; r<=n; r++) {      //  r表示分片长度，从最短的2个矩阵长度 直到  所有矩阵数目n		for(int i=1; i<=n-r+1; i++) {     //  i表示遍历每次长度的起始位置，从1直到倒数第r个元素  //  注意上面的i<=n-r+1 不能改写成 i<n-r；当r增长到跟n一样长时，有等号保证了程序还会处理这种最后情况，否则不处理			int j = i+r-1;     //  j指向该片长下最后一个元素			m[i][j] = m[i][i] + m[i+1][j] + p[i-1]*p[i]*p[j];       //  初始化，假设默认按第一个划分是最优的			s[i][j] = i;			for(int k=i+1; k<j; k++) {  // 遍历该片长下所有情况，因为k指向元素划入前半部分，后半部分不能为空，无等号				int t = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j];				if(t < m[i][j]) {           //  找到更有效的划分，记录下来					m[i][j] = t;					s[i][j] = k;				}			}		}	}}int main() {	int p[7] = {30, 35, 15, 5, 10, 20, 25};	int n = 6;	int m[7][7] = {0};	int s[7][7] = {0};	matrix_chain(p, n, m, s);      //   调用部分，得到最优次数15125，该方法复杂度为O(n3)	for(int j=1; j<7; j++) {		for(int i=1; i<7; i++) {			cout << m[j][i] << " ";		}		cout << endl;	}	getchar();}//  使用分治法进行简单的递归，此方法因为无法避免很多重复计算，有指数的复杂度int recur_matrix_chain(int *p, int i, int j, int s[][7]) {	if(i == j) return 0;	int u = recur_matrix_chain(p, i, i, s) + recur_matrix_chain(p, i+1,j, s) + p[i-1]*p[i]*p[j];	s[i][j] = i;	for(int k=i+1; k<j; k++)	{		int t = recur_matrix_chain(p, i,k, s) + recur_matrix_chain(p, k+1,j, s) + p[i-1]*p[k]*p[j];		if(t < u) 		{			u = t;			s[i][j] = k;		}	}	return u;}//  备忘录方法：本质上还是上面的分治递归，但是加入判断和记录部分，减少了大量计算int look_chain(int *p, int i, int j, int m[][7], int s[][7]) {	if(m[i][j]>0) return m[i][j];   //  保证每次相关计算只计算一次，减少计算，本质上的改变	if(i == j) return 0;	int u = look_chain(p,i,i,m,s) + look_chain(p,i+1,j,m,s) + p[i-1]*p[i]*p[j];	s[i][j] = i;	for(int k=i+1; k<j; k++) {         //  核心部分，遍历一个片段内所有可能解，找出最优		int t = look_chain(p,i,k,m,s) + look_chain(p,k+1,j,m,s) + p[i-1]*p[k]*p[j];		if(t < u) {			u = t;			s[i][j] = k;		}	}	m[i][j] = u;   //  不可少，为了让前面的调用函数可以返回，计算完毕必须填入	return u;}int memorized_matrix_chain(int *p, int n, int m[][7], int s[][7]) {	for(int i=1; i<=n; i++)		for(int j=i; j<=n; j++)			m[i][j] = 0;          // 此处的初始化很重要，后面通过判断是否是初始化值来去掉重复计算	return look_chain(p, 1, n, m, s);}int main() {	int p[7] = {30, 35, 15, 5, 10, 20, 25};	int n = 6;	int m[7][7] = {0};	int s[7][7] = {0};	memorized_matrix_chain(p, n, m, s);}// 总结：当一个问题的所有子问题都至少要解一次时，动态规划算法比备忘录算法好。此时动态规划算法没有任何多余计算//       同时可利用其规则的表格存取方式，减少动态规划算法的计算时间和空间需求//       当子问题空间的部分子问题不必求解时，用备忘录算法比较有利，因为其只需要求解那些确实需要求解的子问题///   最长公共子序列：X={A,B,C,B,D,A,B}  Y={B,D,C,A,B,A}   则最长公共子序列是 Z={B,C,B,A}//    自顶向下分析： X={x1,x2,...,xm}, Y={y1,y2,...,yn}, Z={z1,z3,...,zk}//    (1) 若xm=yn，            则zk=xm=yn，且Z(k-1) 是 X(m-1) 和 Y(n-1)的最长公共子序列//    (2) 若xm!=yn且zk!=xm     则zk=yn，Z是X(m-1) 和 Y的最长公共子序列//    (3) 若xm!=yn且zk!=yn     则zk=xm，Z是x 和 Y(n-1)的最长公共子序列//    自底向上的代码逻辑://                     0                           i=0或j=0//        c[i][j] =  c[i-1][j-1] + 1               i,j>0; xi=yj     相等，就是递归的找剩下部分的最长公共子序列//                   max{c[i][j-1], c[i-1][j]}     i,j>0; xi!=yj    不相等，则最长公共子序列只可能包含X,Y其中一个的头//    a,b是要比较的字符串数组，a[0],b[0]中都没有内容，alength和blength分别为其长度//    c存储前X的前m部分和Y的前n部分的公共子序列长度，d存储，用来输出最长公共子序列void max_common_sequence(char *a, char *b, int alength, int blength, int c[][7], int d[][7]) {	for(int i=0; i<alength; i++)		c[i][0] = 0;	for(int j=0; j<blength; j++)		c[0][j] = 0;	for(int i=1; i<alength; i++) {		for(int j=1; j<blength; j++) {          // 从字符串头开始比较，找可能相同的部分			if(a[i] == b[j]) {                  //  如果都向前遍历时遇到两个字符相同，则成为公共部分				c[i][j] = c[i-1][j-1] + 1;      //  后面的因为内在的包含前面的，所以公共部分长度加一				d[i][j] = 1;                    //   标记其为公共部分			}else if(c[i-1][j] >= c[i][j-1]) {   // 与左边的和上边的比较，取公共部分多的为最后的解				c[i][j] = c[i-1][j];            // 取左边，相当于pass掉了a当前不是公共部分的内容				d[i][j] = 2;                    //  标记2表示 X(i-1) 与 Y(j) 公共部分相同			}else{				c[i][j] = c[i][j-1];            // 取上边，相当于pass掉了b当前不是公共部分的内容				d[i][j] = 3;                    //  标记2表示 X(i) 与 Y(j-1) 公共部分相同			}		}	}}//  输出最长公共子序列void lcs(int i, int j, char *a, char *b, int d[][7]) {    	if(i==0 || j==0) return;      //  公共部分为空序列的时候，不需要输出，递归结束	if(d[i][j] == 1) {		lcs(i-1, j-1, a, b, d);    //  从后往前遍历，所以先递归再输出		cout << a[i];	}else if(d[i][j] == 2){		lcs(i-1, j, a, b, d);	}else if(d[i][j] == 3){		lcs(i, j-1, a, b, d);	}}int main() {	char a[8] = {'1', 'a', 'b', 'c', 'b', 'd', 'a', 'b'};	char b[7] = {'2', 'b', 'd', 'c', 'a', 'b', 'a'};	int c[8][7], d[8][7];	max_common_sequence(a, b, 8, 7, c, d);	for(int i=0; i<8; i++) {		for(int j=0; j<7; j++) {			cout << d[i][j] << " ";		}		cout << endl;	}	lcs(7, 6, a, b, d);	cout << endl;	getchar();}///    字符串2在字符串1中所有的连接次序，例如：abdbcc和abc，连接次序为125，126，145,146（字符位置以1开头）//     通过递归来挨个匹配字符串2中的字符，同时注意存储已经匹配的信息static vector<int> pos_in_str;    // 存储位置信息，要么设置为全局的，要么作为引用参数传给函数void find_sub_str(const char* a, const char* b, int i, int j) {	if(b[j] == '\0') {		for(vector<int>::const_iterator it = pos_in_str.begin(); it!=pos_in_str.end(); it++)			cout << *it;		cout << endl;		return;	}	if(a[i] == '\0') {		return;	}	if(a[i] == b[j]) {		pos_in_str.push_back(i+1);          //  找到相同的元素，压入vector进行存储		find_sub_str(a, b, i+1, j+1);		pos_in_str.pop_back();	}	find_sub_str(a, b, i+1, j);     //  找到或者找不到，都要跳过a当前元素寻找后面的可能性，属于公共步骤}int main()  {      char str1[] = "abdbcca";      char str2[] = "abc";      find_sub_str(str1, str2, 0, 0);      return 0;  } ///   树结构相关定义：主要是结构体和指针typedef int ElemType;        //  定义结点内容typedef struct treeT {	ElemType key;	struct treeT* left;	struct treeT* right;}treeT *pTreeT;        //   treeT是结点变量名，pTreeT是指向结点的指针名///   二叉树的先序、中序、后序遍历：主要思想还是利用“栈”这种数据结构实现，主要有递归方式和非递归方式两种实现方式pTnode getNode(char value) {           //  生成一个节点	pTnode p = new Tnode();	p->a = value;	p->left = NULL;	p->right = NULL;	return p;}//    根据先序遍历得到的数据构造二叉树， 主要利用栈和信号量机制//     非递归的写法：pTreeT BuildTreeByPreOrder(const string &s) {     //  abc##de#g##f###	stack<pTnode> mystack;	if(s.size() < 1) {         //  边界条件判断		return NULL;	}	pTnode p = getNode(s[0]);	pTnode root = p;	int flag = 1;           //   根据abc##de#g##f###构造二叉树，其中#表示空	mystack.push(p);	for(unsigned int i=1; i<s.size(); i++) {		if(s[i] != '#') {			pTnode tmp = getNode(s[i]);			mystack.push(tmp);			if(flag == 1) {				p->left = tmp;			}else{				p->right = tmp;				flag = 1;			}			p = tmp;		}else{			if(flag == 1) {				p->left = NULL;			}else if(flag == 2) {				p->right = NULL;			}			flag = 2;			if(!mystack.empty()) {				p = mystack.top();				mystack.pop();			}		}	}}//   递归的写法： 本质上就是先序遍历递归方法的同构写法pTnode root;int cnt = 0;string s = "abc##de#g##f###";pTnode BuildTreeByPreOrder() {	pTnode thisroot;	if(s[cnt++] == '#') thisroot = NULL;  //  每次判断的同时保证cnt加1	else{		thisroot = new Tnode();		thisroot->a = s[cnt-1];		thisroot->left = BuildTreeByPreOrder();		thisroot->right = BuildTreeByPreOrder();	}	return thisroot;}//    递归方式中，栈由操作系统维护，用户不必关心栈的操作细节struct BiTreeNode{  	 int c;  	 struct BiTreeNode *left;  	 struct BiTreeNode *right;  };  //先序遍历--递归void traverseBiTreePreOrder(BiTreeNode *ptree) {	if(ptree) {		visit(ptree->c);		traverseBiTreePreOrder(ptree->left);		traverseBiTreePreOrder(ptree->right);	}}//中序遍历--递归void traverseBiTreeInOrder(BiTreeNode *ptree) {	if(ptree) {		traverseBiTreeInOrder(ptree->left);		visit(ptree->c);		traverseBiTreeInOrder(ptree->right);	}}//后序遍历--递归void traverseBiTreePostOrder(BiTreeNode *ptree) {	if(ptree) {		traverseBiTreePostOrder(ptree->left);		traverseBiTreePostOrder(ptree->right);		visit(ptree->c);	}}//    非递归方式中，用户//先序遍历--非递归    先visit，因为根肯定已经visit了，所有右孩子入栈int traverseBiTreePreOrder(BiTreeNode *ptree) {	Stack *qs=NULL;	BiTreeNode *pt=NULL;	qs=initStack();	pt=ptree;	while(pt || !isEmpty(qs)) {             //  遍历结束的标志		if(pt) {                        			visit(pt->c);    // visit的位置不同，是与中序遍历的主要差别，先访问再入栈，所有入栈的元素都是没访问过的			//  先序保证根节点已经被访问过，所有可以优化掉已经访问过的根节点，栈里只需要压入未访问节点			push(qs,pt->right); //也可以存当前根节点，然后每次弹栈之后走向其右孩子			pt=pt->left;            //  关键，一路向左		}		else pt=pop(qs);            //  栈中都是右子树，每次弹栈的过程就是遍历右子树的开始	}	return 1;   //正常返回}//中序遍历--非递归  因为每次根不会先visit，所以根先入栈，出栈是里面访问跟，此时左孩子和根都已遍历，走向右孩子int traverseBiTreeInOrder(BiTreeNode *ptree) {	Stack *qs=NULL;	BiTreeNode *pt=NULL;	qs=initStack();	pt=ptree;	while(pt || !isEmpty(qs)) {         //  通过指针和栈同时判断访问是否完毕，有点是内部少一个一直压栈的循环		if(pt) {			push(qs,pt);          //  先入栈再访问，栈顶元素同样都是没访问过的			pt=pt->left;		}else {			pt=pop(qs);			visit(pt->c);         //  与先序的主要区别，visit的位置不同			pt=pt->right;		}	}	return 1;}//中序遍历--非递归--另一种实现方式int traverseBiTreeInOrder(BiTreeNode *ptree) {	Stack *qs=NULL;	BiTreeNode *pt=NULL;	qs=initStack();	push(qs,ptree);	while(!isEmpty(qs)) {// 只通过栈来判断是否访问完毕，所以内部需要有循环连续压栈，否则之后的每次弹栈就让指针不动了		while(pt=getTop(qs)) push(qs,pt->left);    // 每次入栈左孩子，没判断入栈元素是否为空，入栈之后在循环条件中判断		pt=pop(qs);                       // 运行到这肯定是因为前面压入空的左孩子，所以要弹空孩子出栈		if(!isEmpty(qs)) {			pt=pop(qs);			visit(pt->c);			push(qs,pt->right);		}	}	return 1;}//二叉树的morris中序遍历：做法是每次设置叶节点的右孩子为某个根节点，形成线索指针。每次会改变叶节点的右指针，遍历完毕之后会改回来，优点是不需要使用栈等辅助结构，缺点是对每个结点来说，最多可能要经过三次！！！！int morrisTraverseBiTreeInOrder(BiTreeNode *ptree) {	BiTreeNode *p = ptree;    // 用于指向每次遍历的点	BiTreeNode *tmp = NULL;   //  用于缓存做孩子的最右节点(可能为左孩子本身)	while(p) {		if(p->left == NULL) {     // 没有左孩子，则左子树访问完毕，中序遍历输出当前节点			visit(p);     //  对于中序遍历来说，左孩子访问完毕，则输出根节点			p = p->right;       //  接下来遍历右孩子		}else{			tmp = p->left;     // 每次都建立左孩子的最右边的线索			//  第一个条件判断用于建立线索时，左孩子的最右边正好是当前节点中序遍历的前节点			while(tmp->right!=NULL && tmp->right!=p)    // 寻找的过程				tmp = tmp->right;			if(tmp->right == NULL) {   // 仅建立线索时使用，使得right指针指向当前p所指向的根				tmp->right = p;				p = p->left;         //  挨个沿左孩子建立线索			}else{				visit(p);        //  左孩子已经访问完毕，得到tmp->right等于p，此时恢复二叉树结构				tmp->right = NULL;   // 恢复				p = p->right;      // 遍历当前根p的右子树			}		}	}}//后序遍历--非递归int traverseBiTreePostOrder(BiTreeNode *ptree) {	Stack *qs=NULL;	BiTreeNode *pt=NULL;	qs=initStack();	pt=ptree;	while(1) { //循环条件恒“真”  改成 pt || !isEmpty(qs) 也是可以的，不过根据判断跳出也成立		if(pt) {                    //  每个有效节点都会入栈，出栈时即被访问			push(qs,pt);			push(qs,pt->right);        //  关键的一步，放入右孩子，这样保证每次弹栈父节点的时候，右孩子都访问完毕了			pt=pt->left;		}else{			pt=pop(qs);          //  此处每次都弹出的某个右孩子			if(!pt){              //  如果右孩子为空，连续两次出栈都是空，表明左右孩子已经访问完毕，可以输出该节点				pt=pop(qs);         //  弹出父节点输出				visit(pt->c);				if(isEmpty(qs)) return 1;   //   栈空表明所有节点都访问完毕				pt=pop(qs);        //  当前节点访问完毕，当前节点出栈			}			// 此处NULL入栈是个标记，左孩子和右孩子访问完毕时都要标记，所以此处标记功能合并			push(qs,NULL);		}	}	return 1;}///   二叉树的层序遍历： 主要利用队列的先进先出的特性void TraverseBiTreeLevelOrder(pTnode root) {	queue<pTnode> myqueue;	pTnode p = root;	myqueue.push(p);	while(p || !myqueue.empty()) {		if(p) {			visit(p);			myqueue.push(p->left);			myqueue.push(p->right);		}		myqueue.pop();            //  不管p是否指向一个有效元素，都要弹出队列		if(!myqueue.empty()) {			p = myqueue.front();		}	}}///   调用IO相关库实现快速的字符或数字矩阵读入//   注意  << 和 >> 这两个符号只对ascii码文件有效，对二进制文件无效#include <iostream>#include <fstream>#include <sstream>#include <string>using namespace std;void getMatrix(const string &filename) {     // 	ifstream file(filename);            //  通过string类型的变量直接初始化输入流	ofstream outfile("a.txt");          //  可以定义一个输出文件进行输出	string in_line;	//  如果用 file >> in_line 每次只能读入用空格或换行符分隔的一部分，而此处一定要按换行符分隔，getline是string中的库	//  file.getline(array, 100) 的方式也可以，但是array必须是字符数组，100说明可容纳的最大大小，显然不如现在的好	while(getline(file, in_line)) {       //   进行行读入，每次读入整行		istringstream line_stream(in_line);             //  将读入的正行放入istringstream，这个类会对内容按空格分段		string word;		while(line_stream >> word) {          //  将空格分段完毕的字符串挨个读入string变量			stringstream ss;             //  进行string和数值类型的快速转换的媒介			int i;                       //  此处i的类型根据要转换的数值类型来，int，float都可以			ss << word;			ss >> i;			outfile << i << flush;               //  输出到输出文件，flush清空输出缓存		}	}	outfile.close();}///    寻找匹配字符串问题，即已知数组T[1..n]和P[1..m] (n>=m)  找寻 T[s+1..s+m]=P[1..m]的部分(存在与否不确定)//  朴素字符串匹配算法：即从T的每个字符开始，匹配m次，看是否一致  预处理时间0，最坏匹配时间 O((n-m+1)m) T=aaaa P=aavoid native_string_matcher(char *a, char *b, int alength, int blength){	for(int i=0; i<alength-blength+1; i++) {        //  注意i的取值上限，以免数组越界		int k=i;                  // 每次查找起点		bool match = true;		for(int j=0; j<blength; j++, k++) {			if(a[k] != b[j]) {				match = false;				break;			}		}		if(match) {			cout << i << " ";		}	}}//  Rabin-Karp算法：按P串的字符位求取其对应的值，然后在T串中求取n-m+1个值，对比值是否一致//  预处理时间  O(m)  最好时间复杂度为 O(n)  最差O((n-m+1)m)     即 T=aaaa  P = aa//  值的计算与字符的个数有关，以字符的总个数为基，比如10个字符就是10进制，26个就是26进制，其实就是计算每个串的标签值//  遇到P数较大的情况，存不下的时候，可以通过取模来减少值，模q可以小于字符个数，但是这时候存在伪命中，需要检查命中值void rabin_karp_matcher(char *a, char *b, int alength, int blength, int base) {    //  base是每个位对应的基	int move_a_val = 0;	int b_val = 0;	int max_base = 1;	for(int i=0; i<blength; i++) {		move_a_val = a[i] + move_a_val*base;         //  计算T中前m位的标签值		b_val = b[i] + b_val*base;         //  计算待匹配字符串的标签值		max_base = max_base*base;	}	max_base /= base;	for(int i=0; i<alength-blength+1; i++) {		if(move_a_val == b_val) {			cout << i << " ";		}		// 如果放前面的话，每次比较要减去i-1位的值，而第一次比较时0-1位不存在，所以放后面比较好		if(i<alength-blength) {            //  每次判断后面需不需要计算，如果需要，则顺序后移一位			move_a_val = (move_a_val-a[i]*max_base)*base + a[i+blength];		}	}}//  KMP算法：预处理待匹配数组，辅助数组在对应每个位置存储其最长真前缀//  预处理时间 O(m)        时间复杂度  O(n)void compute_prefix_func(char *a, int alength, int *prefixArray) {	prefixArray[0] = 0;   //  第一个没有最长真前缀	int k=0;   	for(int i=1; i<alength; i++) {		while(k>0 && a[k] != a[i])			k = prefixArray[k-1];       //　不等的话，k-1位置存储的可能的最长真前缀的下一个元素的坐标		if(a[k] == a[i])     //  相等则k和i都会一起递增			k++;		prefixArray[i] = k;    //  每次存储的其实是可用的最长真前缀的下一个位置的坐标	}}void kmp_matcher(char *a, int alength, char *b, int blength) {	int *prefixArray = new int[blength]();	compute_prefix_func(b, blength, prefixArray);           //  建立前缀数组	int q=0;	for(int i=0; i<alength; i++) {		while(q>0 && b[q] != a[i])            //  如果等于就跳出来，支持q指向的位置正好是最长前缀的所在			q = prefixArray[q-1];    // 先看q前面存的内容，为到q-1时最大前缀的长度的下一个位置，		if(b[q] == a[i])        //  等于的话意味着q和i同步增长			q++;		if(q == blength) {            //  q从0开始的，此时已超出匹配字符串的长度			cout << i-blength+1 << " ";    //    输出起始位置			q = prefixArray[q-1];       //  找下一个起始位置		}	}}//   Sunday算法：当发现第一个字符不匹配时，直接找T中相隔length长度的字符，没找到直接跳length，找到另算跳过的字符数//   例如   abcdabae 和 bae 首字符a和b不匹配时，找d是否在bae中，如果不在证明d之前的所有字符都不可能匹配//   例如   abcdacdef 和 dacd 不匹配后从后往前找，发现a在dacd中，则移动 4-1=3位，必须从后往前找，否则可能遗漏int match_pos(const char a, char *b, int length) {   //  从后向前找出字符a在字符串b中的位置，返回移动距离	for(int i=length-1; i>=0; i--) {		if(b[i] == a) {			return length-i;		}	}	return length+1;             //  如果没找到，整个字符串长度 加上 当前判断的字符都可以跳过}void sunday_matcher(char *a, int alength, char *b, int blength) {	int i=0;	while(i<alength-blength+1) {		int j=0;		while(j<blength) {			if(a[i+j] != b[j]) {      //  挨个字符比较，如果不匹配立马跳出				break;			}			j++;		}		if(j==blength) {          //  匹配则输出，同时从接下来的字符继续查找			cout << i << " ";			i++;			continue;		}		int pos = match_pos(a[i+blength], b, blength);   //  从length下一位的字符开始检查，获得应该移动的距离		i += pos;	}}///  寻找特殊二维数组中某个元素的问题//   二维数组中，每一行从左到右递增，第一列从上到下递增//   利用有序的特性，每次消一列或者一行，此处是主消除列的方法，消除行的方法主要更改else if这句bool Find(int* matrix, int rows, int columns, int number) {       // 注意到传的是一维数组形式的二维数组	bool found = false;	if(matrix != NULL && columns>0 && rows>0) {      //  判断三个输入参数是否有效，一起判断更省代码空间		int row = 0;		int column = columns - 1;     //  主消除列的定义		while(column>=0 && row<rows) {			if(matrix[row*columns + column] == number) {				found = true;				break;			}else if(matrix[row*columns + column] > number) {       // 每列的第一个比number还大时，直接消除列				column--;			}else{				row++;                //  行的递进			}		}	}	return found;}///  判断一个输入数字是否是回文串//   转成字符串判断需要开辟额外空间，反转数字判断是否与原数字相等的方法有反转数字溢出的风险//   想法：通过除法和取余，获得每个要比较的数字bool is_palindrome(int num) {	if(num < 0) {		return false;	}	int left_modulo = 1;	int right_modulo = 1;	int num_size = 0;	int tmp_num = num;	while(tmp_num) {		num_size++;      // 求得数的长度		tmp_num /= 10;		// 求得左边用来取数的模的大小，放在循环里面判断相比于每次直接乘10再在外面除以10的好处是不会溢出		if(tmp_num)			left_modulo *= 10;   	}	for(int i=0; i<num_size/2; i++) {		if((num/left_modulo)%10 != (num/right_modulo)%10) // 通过取得包含对应位前面的所有数字再取模得到对应数字			return false;		left_modulo /= 10;		right_modulo *= 10;	}	return true;        // num为0的情况直接跳过两个循环返回true}///  表达式求值：字符串里面只有+ - *三个符号和非负整数       例如： 7+3*4*5+2+4-3-1//   方法1：通过栈存储数字，每次遍历时处理前一个符号，前一个符号是-或者*时进行处理，最后只需要对所有栈内元素求和即可int evaluate(const string& expr) {	int num=0;        // 用来取得每个连续的数	int result = 0;          //　返回最终结果	char pre_sign = '+';     // 相当于在整个字符串前面加了个 0+ 不影响最终结果	stack<int> mystack;	for(int i=0; i<expr.size(); i++) {		if(expr[i]=='*' || expr[i]=='+' || expr[i]=='-') {  //  此时获得了第二个数，从而可以处理前一个符号			if(pre_sign == '*') {            //  * 时，把当前数和栈顶元素求积				int pre_num = mystack.top();				mystack.pop();				num *= pre_num;				mystack.push(num);			}else if(pre_sign == '-') {   // - 时，把当前元素取负				mystack.push(-num);			}else{				mystack.push(num);     // + 时，直接入栈			}			pre_sign = expr[i];			num = 0;                   // 重新计算下一个数		}else{			num = num*10 + expr[i] - '0';      // 每个数的获得		}	}	if(pre_sign == '*') {         //  处理最后一个符号和最后一个数的边界情况		int pre_num = mystack.top();		mystack.pop();		num *= pre_num;		mystack.push(num);	}else if(pre_sign == '-') {		mystack.push(-num);	}else{		mystack.push(num);	}	while(!mystack.empty()) {       //  栈内所有元素求和即得所求结果		result += mystack.top();		mystack.pop();	}	return result;}//  方法2：递归求解，每次求取表达式最右边的* 和 +/- 同时计算数值，如果存在，按优先级进行递归，不存在则返回数值int evaluate(const string& expr, int begin, int end) {   // 外部保证begin必然大于end，递归内部不会出现这种情况	int plusIndex = -1, mulIndex = -1, sign = 1;   // 分别为+/-标记，*标记 和 减号符号标记	int num = 0;          //  存储整个字符串的值	//  每次找到字符串最右边的 +/- 和 *  ，之所以找右边的，是因为减号是又结合性的，找左边的话 1-2-3会分类成 1-(2-3)	//  不从右边忘左边找，找到break的原因是，如果没有符号只有数字，则在遍历过程中求得num	for(int i=begin; i<=end; i++) {        		if(expr[i] == '+' || expr[i] == '-') {			plusIndex = i;			sign = expr[i]=='+'?1:-1;		}else if(expr[i] == '*') {			mulIndex = i;		}		num = num*10 + expr[i] - '0';        //  如果整个字符串里面没有符号，则返回整个值	}	//  因为 +/- 的优先级低，所以先递归，优先级高的*在深层次的递归里面先算	if(plusIndex != -1) return evaluate(expr, begin, plusIndex-1) + sign*evaluate(expr, plusIndex+1, end);	if(mulIndex != -1) return evaluate(expr, begin, mulIndex-1) * evaluate(expr, mulIndex+1, end);	return num;}///  链表的常用处理代码struct ListNode {            // 简单的链表结构定义	int m_nValue;	ListNode* m_pNext;};// 此处传入参数必须是指向指针的指针，因为指针本身是形参，内容修改不会传递到外部，只有修改指针指向的内容才影响外部// 因为是作为函数的参数传递所以要写成指向指针的指针，如果直接在main函数里处理不用这么定义void AddToTail(ListNode** head, int value) {  	if(head == NULL)		return;  	ListNode* pNew = new ListNode();	pNew->m_nValue = value;	pNew->m_pNext = NULL;	if(*head == NULL) {   //  此处判空是为了while循环的简化		*head = pNew;	}else{		ListNode* pNode = *head;		while(pNode->m_pNext != NULL) {			pNode = pNode->m_pNext;		}		pNode->m_pNext = pNew;	}}void RemoveNode(ListNode** head, int value) {	if(head == NULL && *head == NULL)         //  两个非空都要判断，缺一不可，鲁棒性		return;	ListNode* pToBeDeleted = NULL;      // 定义这样一个指针便于统一删除，否则代码里会多次出现delete，不利于维护	if((*head)->m_nValue == value) {   // 头的情况比较特殊，要特殊处理		pToBeDeleted = *head;		*head = (*head)->m_pNext;	}else{		ListNode* pNode = *head;        // 遍历指针的定义		while(pNode->m_pNext != NULL) {			if(pNode->m_pNext->m_nValue == value) {				pToBeDeleted = pNode->m_pNext;				pNode->m_pNext = pNode->m_pNext->m_pNext;				break;			}else{				pNode = pNode->m_pNext;			}		}	}	if(pToBeDeleted != NULL) {     // 统一删除，便于代码维护		delete pToBeDeleted;		pToBeDeleted = NULL;      // 悬垂指针置空是个好习惯	}}//  单链表反转：  主要分为递归算法 和 非递归算法//  Node* reverse(Node* head) {	if(head == NULL) return NULL;        //  即是处理的空链表，也处理链表结尾的空	if(head->next == NULL) return head;   //  处理单个节点的链表  或者  链表的倒数第一个节点	Node* ph = reverse(head->next);     //  能运行到这里，说明head->next不为空，即从倒数第二个点开始递归	head->next->next = head;     //  深层递归里执行的部分，对1,2的节点编号，让2的next指向1	head->next = NULL;       //  让1的next指向NULL，此时2已经调整完毕，所有1的next的原始值不会再用到	return ph;  // ph都是每次reverse返回的值，最深层的reverse返回的是最后一个节点，正是反转后的头节点，	//  只要ph被赋上有意义的值之后，这个值其实一直没变过}Node* reverse(Node* head) {        // 	if(head == NULL) return NULL;	if(head->next == NULL) return head;       //  能执行后面的语句，保证了链表里至少有两个节点	Node* preNode = NULL;          //  使得第一个节点指向空	Node* curNode = head;          //  指向第一个节点	Node* nextNode = head->next;   //  指向第二个节点	while(nextNode != NULL) {		curNode->next = preNode;        //  当前节点指向前节点		preNode = curNode;              //  前节点后移一位，前节点与当前节点一直是中断关系		curNode = nextNode;             //  当前节点后移一位，循环判断条件保证curNode不空		nextNode = nextNode->next;      //  后节点后移一位	}	curNode->next = preNode;      //  跳出循环，此时当前节点为原链表最后一个节点	return curNode;}/// 找出现次数不匹配：给定一个包含n个整数的数组，除了一个数出现一次外所有的整数均出现三次，找出这个只出现一次的整数//  对于每一个出现三次的数来说，对于其每个二进制位，肯定也出现了三次，则用一个三进制的形式来记录每一个位出现1的次数//  则最后结束时，能找到对应位上出现次数不等于3的，对应的就是要找的落单的数int singleNumber(int A[], int n) {     // A是待测数组，n是数组长度	int ones = 0;        //  ones用来记录已经出现过的数中  某一位中1出现了3n+1的情况，初始化不能少！！！  	int twos = 0;        //  twos用来记录已经出现过的数中，某一位中1出现了3n+2的情况	int ternary_eliminate = 0;  // 某一位的1出现3次时，满足三进制则进位，因为只记进位的余数，所以要消除已经进位的部分	for(int i=0; i<n; i++) {		twos |= (ones & A[i]);      // ones & A[i] 得到加入A[i]后出现2次的部分，进行进位，同时twos中已有的1要保留		ones ^= A[i];      //   ones 得到本次计算结束后该位对应只出现1次的结果，同1和同0的都不会留下只出现一次的情况		ternary_eliminate = ~(ones & twos);   // ones & twos得到要进位的部分，取反之后得到map用来获得留下来的部分		ones &= ternary_eliminate;   // 实现三进制进位操作的部分，出现三次的位都消掉		twos &= ternary_eliminate;   // 同上		//  因为有上面两步的消除工作，所以不可能出现对某一位ones和twos上都为1的情况，即该进位的时候不进位的情况	}	return ones;        //  如果落单数只出现两次，则返回twos，如果出现两个落单一次的数，则本方法无法区分}int A[] = {1,2,3,5,6,1,2,3,5,6,1,2,3,5,6,7};     //  测试数组