<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Vue 示例</title>
</head>
<body>
	<div id="app">

		<!------------------------------ 父组件通过props发送信息给子组件 ------------------------------>
		<!-- 此处通过v-bind绑定的message指向父组件的data字段，然后props数组中声明message来实现，除了传数组，还可以传对象 -->
		<global-component :message='myprint' :init-count="1"></global-component>
		<local-component></local-component>

		<!-- 对于html元素<table>中规定只能出现<tr><td><th>导致直接使用组件无效的情况，通过is属性来挂载 -->
		<table>
			<tbody is="local-component"></tbody>
		</table>

		<!------------------------------ 子组件通过事件发送消息给父组件 ------------------------------>
		<p>总数: {{total}}</p>
		<!-- 父组件在子组件上通过v-on绑定两个自定义标签increase和reduce来监听事件，
				然后与父组件的handleGetTotal方法绑定实现调用父组件该方法的效果 -->
		<my-component @increase="handleGetTotal" @reduce="handleGetTotal"></my-component>
		<!-- 使用.native修饰符监听原生事件click，监听的是该组件的根元素 -->
		<my-component v-on:click.native="handleClick"></my-component>

		<p>total2： {{total2}}</p>
		<!-- 使用v-model来绑定数据total2，而不是使用v-on绑定事件，达到同样的效果 -->
		<my-component2 v-model="total2"></my-component2>

		<!-- 定义一个Vue对象用户在非父子组件之间传递数据 -->
		<p>{{message}}</p>
		<component-a></component-a>


		<hr>
		<my-button></my-button>
		<br>
		<my-button></my-button>

	</div>
<script src="https://unpkg.com/vue/dist/vue.min.js"></script>
<script>
	/*所有组件都必须是DOM元素，直接摆内容是无法识别的*/

	/*注册全局组件my-component */
	Vue.component('global-component', {
		/*使用props来声明需要从父级接收的数据，与data属性的主要区别是数据来自父级，
			message是自定义的接收标签，传递多个数据的时候可以自己继续往数组添加，
			这些数据可以在本组件的template, computed,methods等属性中使用
			html标签不区分大小写，所以横线自动转驼峰*/
		props: ['message', 'initCount'],
		template: '<div>全局注册的组件: {{message}}</div>',
		data: function() {
			/*在组件内部使用外部传入的数据时，建议在data内部再声明对象存储，做到与入参隔离*/
			return { count : this.initCount }
		}
	});

	/*验证父级传入参数的写法，
		可以验证的类型： String, Number, Boolean, Object, Array, Function*/
	Vue.component('comp-validate', {
		props: {
			/*必须传入数字*/
			propA: Number,  
			/*必须传入数字或者字符串*/
			propB: [String, Number],
			/*传入布尔值，没有定义的话默认是true*/
			propC: {
				type: Boolean,
				default: true
			},
			/*数字，而且必传*/
			propD: {
				type: Number,
				required: true
			},
			/*如果是数组或对象，默认值必须是一个函数来返回*/
			propE: {
				type: Array,
				default: function() {
					return [];
				}
			},
			/*自定义验证函数*/
			propF: {
				validator: function(value) {
					return value > 10;
				}
			},
		}
	})

	Vue.component('my-component', {
		template: '\
			<div>\
				<button @click="handleIncrease">+1</button>\
				<button @click="handleReduce">-1</button>\
			</div>',
			data: function() {
				return {counter : 0}
			},
		methods: {
			/*子组件发射事件给父组件，此处发生事件increase，并使用本地的counter值作为参数*/
			handleIncrease: function() {
				this.counter++,
				this.$emit('increase', this.counter);
			},
			handleReduce: function() {
				this.counter--,
				this.$emit('reduce', this.counter);
			}
		}
	});


	Vue.component('my-component2', {
		props: ['value'],
		/*此处自定义子组件的表单输入组件，进行数据双向绑定*/
		template: '<input :value="value" @input="updateValue">',
		methods: {
			updateValue: function(event) {
				this.$emit('input', event.target.value);
			}
		}
	});

	var bus = new Vue();
	Vue.component('component-a', {
		template: '<button @click="handleEvent">传递事件</button>',
		methods: {
			handleEvent: function() {
				bus.$emit('on-message', '来自组件component-a的内容');
			}
		}
	});

	
	var data = { counter: 0};
	Vue.component('my-button', {
		template: '<buttion @click="counter++">{{counter}}</buttion>',
		data: function() {
			/*内部定义的对象，与每个组件本身绑定，在组件之间不相互影响*/
			return { counter : 0 };
			/*组件引用同一个外部对象时，修改产生的效果对所有该组件生效*/
			/*return data;*/
		}
	});

	var Child = {
		template: '<div>局部注册的组件</div>',
		/*组件内部的data必须是函数*/
		data: function() {
			return { message: '组件内容'}
		}
	};

	var app = new Vue({
		el: '#app',
		/*使用components属性注册局部组件*/
		components: {
			'local-component': Child
		},
		data:{
			myprint: "来自父组件的数据",
			total: 0,
			total2: 0,
			message: '',
		},
		methods: {
			handleGetTotal: function(total) {
				this.total = total;
			},
			handleClick: function() {
				console.log("在子组件上点击了一下");
			}
		},
		mounted: function() {
			var _this = this;
			bus.$on('on-message', function(msg) {
				_this.message = msg;
			});
		},
	})
</script>
</body>
</html>