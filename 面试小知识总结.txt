代码覆盖测试分为：函数覆盖，语句覆盖，判断覆盖，条件覆盖，路径覆盖

软件开发生命周期模型有：瀑布模型、快速原型模型、迭代模型

根据数据结构类型的不同，可以将数据模型划分为层次模型、网状模型和关系模型。

设置第3位和清除第3位的操作：
#define BIT3 (0x1 << 2)
void set_bit3(const int &a) {
	a |= BIT3;
}
void get_bit3(const int &a) {
	a &= ~BIT3;
}

设定某个具体内存地址的具体值
int *pr;
pr = (int *)0x6719;
(*pr) = 0xaa66;

char *p = new char[0];           //  整个程序合法，最后运行结果为is not null
if(p == NULL) {
	cout << "is null" << endl;
}else{
	cout << "is not null" << endl;
}

都是声明结构体s的指针，但第二个更好，原因如下
#define dPS struct s *             //  dPS p1,p2;      //  声明时由于结合性，p2被声明为一个普通结构体变量
#typedef struct s * tPS            //  tPS p1,p2;      //  两个都是合法的声明


 typedef void(*Fun)(void);    //  定义了一个指想函数的指针别名，别名是Fun
 class Base {
     public:
            virtual void f() { cout << "Base::f" << endl; }
            virtual void g() { cout << "Base::g" << endl; }
            virtual void h() { cout << "Base::h" << endl; }
};
Base b;
Fun pFun = NULL;
cout << "虚函数表地址：" << (int*)(&b) << endl;
//  第一个int *是为了转成普通的指针取得该位置所指向的虚函数表的地址
cout << "虚函数表 ― 第一个函数地址：" << (int*)*(int*)(&b) << endl;        
pFun = (Fun)*((int*)*(int*)(&b));       // 取得虚函数表首地址内的内容，然后用Fun转换成函数指针
pFun();
(Fun)*((int*)*(int*)(&b)+0);  // Base::f()
(Fun)*((int*)*(int*)(&b)+1);  // Base::g()
(Fun)*((int*)*(int*)(&b)+2);  // Base::h()
多重继承的时候，在子类中，对于继承的每一个父类，都有一个虚函数表指针，指向的虚函数表存储父类的所有函数
子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）



静态多态性：函数多态性――函数重载
            模板多态性――C++模板（类模板、函数模板）
动态多态性：虚函数（只有用地址才能实现动态多态性）

只有采用“指针->函数()”或“引用变量.函数()”的方式调用C++类中的虚函数才会执行动态绑定。对于C++中的非虚函数，因为其不具备动态绑定的特征，所以不管采用什么样的方式调用，都不会执行动态绑定。

                                对于虚函数                                            对于非虚函数
代码形式           作用                               绑定方式          作用                                  绑定方式
类名::函数()       调用指定类的指定函数               静态绑定          调用指定类的指定函数                  静态绑定
对象名.函数()      调用指定对象的指定函数             静态绑定          调用指定对象的指定函数                静态绑定
引用变量.函数()    调用被引用对象所属类的指定函数     动态绑定          调用引用变量所属类的指定函数          静态绑定
指针->函数()       调用被引用对象所属类的指定函数     动态绑定          调用指针变量所属类的指定函数          静态绑定

从上表可以看出，执行动态绑定的只有通过地址，即只有通过指针或引用变量才能实现，而且还必须是虚函数。从概念上来说，虚函数机制只有在应用于地址时才有效，因为地址在编译阶段提供的类型信息不完全。								 

class B  {  
    void DoSomething();  
    virtual void vfun();  
} 
class D : public B  {  
    void DoSomething();  
    virtual void vfun();  
}  
D* pD = new D();         pD->DoSomething();    	// 调用的D中的函数，因为非virtual都是静态绑定
B* pB = pD;               pB->DoSomething();      //  调用B中的函数
虽然pD和pB都指向同一个对象。因为函数DoSomething是一个no-virtual函数，它是静态绑定的，也就是编译器会在编译期根据对象的静态类型来选择函数。pD的静态类型是D*，那么编译器在处理pD->DoSomething()的时候会将它指向D::DoSomething()。同理，pB的静态类型是B*，那pB->DoSomething()调用的就是B::DoSomething()。
个人理解：在D类的空间里，第一个虚函数表里面两个DoSomething都存储了，分别以B::DoSomething()和D::DoSomething()的形式存储的，运行时会根据指针的类型选择该调用哪个DoSomething()

让我们再来看一下，pD->vfun()和pB->vfun()调用的是同一个函数吗？
是的。因为vfun是一个虚函数，它动态绑定的，也就是说它绑定的是对象的动态类型，pB和pD虽然静态类型不同，但是他们同时指向一个对象，他们的动态类型是相同的，都是D*，所以，他们的调用的是同一个函数：D::vfun()。
个人理解：在D类的空间里，用D::vfun()覆盖了原来B::vfun的内容，所以即使pB和PD静态类型不同，但是指向同一个对象，这个对象里面只有D::vfun()

只有虚函数才使用的是动态绑定，其他的全部是静态绑定。
class B {
 virtual void vfun(int i = 10)  cout << "B:" << i << endl;
}
class D : public B {
 virtual void vfun(int i = 20)  cout << "D:" << i << endl;
} 
D* pD = new D();
B* pB = pD;
pD->vfun();      //  输出为： D:20     
pB->vfun();      //  输出为： D:10     此时i使用10初始化的，注意到函数内的东西还是一样的，只是形参是静态绑定的

当缺省参数和虚函数一起出现的时候情况有点复杂，极易出错。
分析一下，缺省参数是静态绑定的，pD->vfun()时，pD的静态类型是D*，所以它的缺省参数应该是20；同理，pB->vfun()的缺省参数应该是10。
个人理解：形参是压栈的，跟程序的代码区是分开的，在调用这个函数时，根据默认参数初始化形参，此时形参与代码是分离的
编程军规：绝不重新定义继承而来的缺省参数!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

++i  与  i++  前置++与后置++重载的写法
class Integer {
public:
	Integer(long data): m_data(data) {}         //  构造函数
	Integer& operator++() {
		m_data++;
		return *this;
	}
	Integer operator++(int) {
		Integer temp = *this;
		m_data++;
		return temp;       //   返回这个对象的旧值
	}
}

++i  与  i++   效率上的区别
内建数据类型的情况，效率没有区别。
自定义数据类型的情况，++i效率较高。
考虑内建数据类型时，它们的效率差别不大（去除编译器优化的影响）。所以在这种情况下我们大可不必关心。
现在让我们再考虑自定义数据类型（主要是指类）的情况。此时我们不需要再做很多汇编代码的分析了，因为前缀式（++i）可以返回对象的引用，而后缀式（i++）必须产生一个临时对象保存更改前对象的值并返回(实现过自定义类型++运算符定义的就知道)，所以导致在大对象的时候产生了较大的复制开销，引起效率降低，因此处理使用者自定义类型（注意不是指内建类型）的时候，应该尽可能的使用前缀式地增/递减，因为他天生体质较佳。



查找N个数里面的前K大的数的方法：

方法一：将N个数从大到小排序，然后取前K个数，排序算法平均复杂度为 NlogN

方法二：维护一个K大小的有序数组，每次取数跟数组里面最小的元素比，小就舍弃，最坏时间复杂度  N*K，每次要比完数组所有元素

方法三：采用小顶堆，每次跟堆顶比，更大就替换，然后重新建堆，由于建堆操作是 logK 的复杂度，整体变成  N*logK


邻接表  综合了  数组查表快的优势  和    链表插入删除快的优势
其关键在于利用 hash 确定映射到哪个数组上去

元素特征转变为数组下标的方法就是散列法 即hash，有三种基本方法：
1，除法散列法         index = value % 16 
2，平方散列法         index = (value * value) >> 28
3，斐波那契（Fibonacci）散列法   index = (value * 2654435769) >> 28
	对于16位整数而言，这个乘数是40503
	对于32位整数而言，这个乘数是2654435769
	对于64位整数而言，这个乘数是11400714819323198485
	
	
在散列过程中可以进行的调整
d-left hashing中的d是多个的意思，我们先简化这个问题，看一看2-left hashing。2-left hashing指的是将一个哈希表分成长度相等的两半，分别叫做T1和T2，给T1和T2分别配备一个哈希函数，h1和h2。在存储一个新的key时，同 时用两个哈希函数进行计算，得出两个地址h1[key]和h2[key]。这时需要检查T1中的h1[key]位置和T2中的h2[key]位置，哪一个 位置已经存储的（有碰撞的）key比较多，然后将新key存储在负载少的位置。如果两边一样多，比如两个位置都为空或者都存储了一个key，就把新key 存储在左边的T1子表中，2-left也由此而来。在查找一个key时，必须进行两次hash，同时查找两个位置。


哈希表的尺寸最好是一个质数


大数据量ip地址找出现频率最高的：先将ip分片，分片方法为ip地址模1024，分成1024个小文件，每个的最后10二进制位都相同，然后在每个文件里找出现频率最多的

counting bloom filter 对应每一个位加一个计数器，这样就可以支持删除功能了，否则普通bloom filter每次删除都要重新建


不使用乘除法、for、while、if、else、switch、case 等关键字以及条件判断语句
#define  T(X, Y, i) (Y & (1<<i)) && X+=(Y<<i)         //    如果某位置上有1的话，要加上对应这个位置的倍数的被乘数
int foo(int n){
  int r=n;
  T(r, n, 0); T(r, n,1); T(r, n, 2); … T(r, n, 31);
  return r >> 1;
}


级联与堆叠：
级联是通过集线器的某个端口与其它集线器相连的，如使用一个集线器UPLINK口到另一个的普通端口；而堆叠是通过集线器的背板连接起来的，它是一种建立在芯片级上的连接，如2个24口交换机堆叠起来的效果就像是一个48口的交换机，优点是不会产生瓶颈的问题。

